/*
  Copyright (C) 2002-2020 CERN for the benefit of the ATLAS collaboration
*/

inline void
BFieldCache::getB(const double* xyz,
                  double r,
                  double phi,
                  double* B,
                  double* deriv) const
{

  const double& x(xyz[0]);
  const double& y(xyz[1]);
  const double& z(xyz[2]);

  // make sure phi is inside [m_phimin,m_phimax]
  if (phi < m_phimin) {
    phi += 2 * M_PI;
  }
  // fractional position inside this bin
  float fz = (z - m_zmin) * m_invz;
  float gz = 1.0 - fz;
  float fr = (r - m_rmin) * m_invr;
  float gr = 1.0 - fr;
  float fphi = (phi - m_phimin) * m_invphi;
  float gphi = 1.0 - fphi;
  // interpolate field values in z, r, phi
  float Bzrphi[3];
  for (int i = 0; i < 3; i++) { // z, r, phi components
    const float* field = m_field[i];
    Bzrphi[i] = m_scale * (gz * (gr * (gphi * field[0] + fphi * field[1]) +
                                 fr * (gphi * field[2] + fphi * field[3])) +
                           fz * (gr * (gphi * field[4] + fphi * field[5]) +
                                 fr * (gphi * field[6] + fphi * field[7])));
  }
  // convert (Bz,Br,Bphi) to (Bx,By,Bz)
  float invr;

  float c;

  float s;
  if (r > 0.0) {
    invr = 1.0 / r;
    c = x * invr;
    s = y * invr;
  } else {
    invr = 0.0;
    c = cos(m_phimin);
    s = sin(m_phimin);
  }
  B[0] = Bzrphi[1] * c - Bzrphi[2] * s;
  B[1] = Bzrphi[1] * s + Bzrphi[2] * c;
  B[2] = Bzrphi[0];

  // compute field derivatives if requested
  if (deriv) {
    float sz = m_scale * m_invz;
    float sr = m_scale * m_invr;
    float sphi = m_scale * m_invphi;
    float dBdz[3];

    float dBdr[3];

    float dBdphi[3];
    for (int j = 0; j < 3; j++) { // Bz, Br, Bphi components
      const float* field = m_field[j];
      dBdz[j] =
        sz *
        (gr * (gphi * (field[4] - field[0]) + fphi * (field[5] - field[1])) +
         fr * (gphi * (field[6] - field[2]) + fphi * (field[7] - field[3])));
      dBdr[j] =
        sr *
        (gz * (gphi * (field[2] - field[0]) + fphi * (field[3] - field[1])) +
         fz * (gphi * (field[6] - field[4]) + fphi * (field[7] - field[5])));
      dBdphi[j] =
        sphi * (gz * (gr * (field[1] - field[0]) + fr * (field[3] - field[2])) +
                fz * (gr * (field[5] - field[4]) + fr * (field[7] - field[6])));
    }
    // convert to cartesian coordinates
    float cc = c * c;
    float cs = c * s;
    float ss = s * s;
    float ccinvr = cc * invr;
    float csinvr = cs * invr;
    float ssinvr = ss * invr;
    float sinvr = s * invr;
    float cinvr = c * invr;
    deriv[0] = cc * dBdr[1] - cs * dBdr[2] - csinvr * dBdphi[1] +
               ssinvr * dBdphi[2] + sinvr * B[1];
    deriv[1] = cs * dBdr[1] - ss * dBdr[2] + ccinvr * dBdphi[1] -
               csinvr * dBdphi[2] - cinvr * B[1];
    deriv[2] = c * dBdz[1] - s * dBdz[2];
    deriv[3] = cs * dBdr[1] + cc * dBdr[2] - ssinvr * dBdphi[1] -
               csinvr * dBdphi[2] - sinvr * B[0];
    deriv[4] = ss * dBdr[1] + cs * dBdr[2] + csinvr * dBdphi[1] +
               ccinvr * dBdphi[2] + cinvr * B[0];
    deriv[5] = s * dBdz[1] + c * dBdz[2];
    deriv[6] = c * dBdr[0] - sinvr * dBdphi[0];
    deriv[7] = s * dBdr[0] + cinvr * dBdphi[0];
    deriv[8] = dBdz[0];
  }
}


