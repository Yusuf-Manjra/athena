package AtlasPolicy

author    Christian Arnault <arnault@lal.in2p3.fr>

use ExternalPolicy ExternalPolicy-* External
use AtlasCxxPolicy AtlasCxxPolicy-*
use AtlasCommonPolicy AtlasCommonPolicy-*

use GaudiPolicy v* -no_auto_imports

#-------------------------------------------------------------
#  Those package dependencies should lead to empty settings
# except when running the corresponding activity
# eg. when running gmake doxygen  
use CodeCheck CodeCheck-* Tools
use AtlasDoxygen AtlasDoxygen-* Tools

# Specify additional tag associations
tag dbg debug
tag debug dbg
tag opt optimized 
tag optimized opt
tag prof profiled
tag profiled prof
tag pro profiled
tag profiled pro

# Specify Common Unix tag associations
tag Linux   Unix
tag Solaris Unix
tag Darwin  Unix

tag Unix&static UnixStatic

# Tag to activate by default the generation of Configurables in all
# the Athena components
# This can be de-activated by:
# private
#   apply_tag no_genconf
# end_private
apply_tag do_genconf

# Patch the component library link options declared in GaudiPolicy to 
# ATLAS convention. Note that this is disabled altogether when debug is
# enabled.

# First remove whatever GaudiPolicy set
macro_remove componentshr_linkopts " -Wl,-Bsymbolic"
macro_remove componentshr_linkopts " -Wl,-s"

# Remove Gaudi linkopts depending on the setting of the notAsNeeded/asNeeded CMT tags. These are
# setup within the External/PlatformPolicy package.

macro_remove componentshr_linkopts "-Wl,--no-undefined" notAsNeeded "-Wl,--no-undefined" asNeeded ""
macro_remove componentshr_linkopts "-Wl,--as-needed"    notAsNeeded "-Wl,--as-needed"    asNeeded ""
macro_remove libraryshr_linkopts   "-Wl,--no-undefined" notAsNeeded "-Wl,--no-undefined" asNeeded ""
macro_remove libraryshr_linkopts   "-Wl,--as-needed"    notAsNeeded "-Wl,--as-needed"    asNeeded ""
macro_remove cpplinkflags          "-Wl,--no-undefined" notAsNeeded "-Wl,--no-undefined" asNeeded ""
macro_remove cpplinkflags          "-Wl,--as-needed"    notAsNeeded "-Wl,--as-needed"    asNeeded ""

# additional (otherwise optional) flags for working with GaudiHive
macro_append cppflags ""    \
  HIVE   " -DATHENAHIVE "
macro_append reflex_dict_options_cppflags "" \
  HIVE   " -DATHENAHIVE "

# The allowUndefined tag is weaker than the notAsNeeded tag but allows symbols to remain undefined
# after linking libraries.

macro_remove componentshr_linkopts "" Darwin&allowUndefined "" allowUndefined "-Wl,--no-undefined"
macro_remove libraryshr_linkopts   "" Darwin&allowUndefined "" allowUndefined "-Wl,--no-undefined"
macro_remove cpplinkflags          "" Darwin&allowUndefined "" allowUndefined "-Wl,--no-undefined"
macro_remove shlibflags            "" Darwin&allowUndefined "" Darwin         " -undefined suppress"
macro_append shlibflags            "" Darwin&allowUndefined "" Darwin         " -undefined error"

# Setup platform-specific linkopts and macros

macro asNeeded_linkopt    "" \
      Darwin              "" \
      notAsNeeded         "" \
      asNeeded            "-Wl,--as-needed"

macro notAsNeeded_linkopt "" \
      Darwin              "" \
      notAsNeeded         "" \
      asNeeded            "-Wl,--no-as-needed" 

# Add the default Linux component library link options
macro_append componentshr_linkopts "" \
             debug                 "" \
	     separate-debug&target-opt "" \
             Linux                 " -Wl,-s "

# Add 64-bit link options for SLC5. This overrides the default library segment alignment of 1MB
macro_append componentshr_linkopts "" \
             slc5&64               " -Wl,-z,max-page-size=0x1000 "
macro_append libraryshr_linkopts   "" \
             slc5&64               " -Wl,-z,max-page-size=0x1000 "

# Setup application link flags. This was added to deal with a problem
# with SEAL 1.4.0, so should be reviewed later
macro_append cpplinkflags "" \
      Linux               " -Wl,--export-dynamic "
# Explicitly allow undefined symbols in shared libraries
# linked against applications
macro_append cpplinkflags "" \
      Linux               " -Wl,--allow-shlib-undefined "

# This solves linkage problems when cross-building mac105 (Leopard) libraries on 
# a mac106 (Snow Leopard) machine 
macro_append cpplinkflags       "" \
      host-mac106&target-mac105 " -lstdc++ -lgcc_s.10.4 "

#Enable hash-style=both since we get some benefit (speadup in loading libs)
macro_append componentshr_linkopts      "" \ 
                Linux                   " -Wl,--hash-style=both " 
macro_append libraryshr_linkopts        "" \ 
                Linux                   " -Wl,--hash-style=both " 
macro_append cpplinkflags       "" \ 
        Linux                   " -Wl,--hash-style=both " 




#--------------------------------------------
# MN: define patterns missing in ROOT5 based LCG

macro rootver_dependent_setup  "root5_setup" \
      ROOT_GE_6_00             "root6_setup"

pattern root5_setup \
   pattern set_root_include_path ""

pattern root6_setup \
   ""

apply_pattern $(rootver_dependent_setup)


#-------------------------------------------------------------
# Global patterns (systematically applied)
#-------------------------------------------------------------

ignore_pattern include_none

pattern -global default_include_path \
    macro <package>_include_dirs "$(<package>_cmtpath)/$(<project>_installarea_prefix)/include/<package>" \
        <project>_without_installarea "$(<PACKAGE>ROOT)" ; \
    private ; \
    macro <package>_include_dirs "$(<PACKAGE>ROOT)" ; \
    end_private ; \
    include_dirs ${<package>_include_dirs} ; \
    macro <package>_root_include_path "$(<package>_cmtpath)/$(<project>_installarea_prefix)/root-include-path" \
        <project>_without_installarea "$(<PACKAGE>ROOT)" ; \
    private ; \
    macro <package>_root_include_path "$(<PACKAGE>ROOT)" ; \
    end_private ; \
    document install_root_include_path install_root_include_path ; \
    document install_includes install_includes

#  include_dirs $(<package>_cmtpath)/$(cmt_installarea_prefix)/include/<package> 

#
# Don't setup a default include path for this package
#
ignore_pattern default_include_path

cmtpath_pattern \
    path_prepend DYLD_LIBRARY_PATH "" <project>_with_installarea&Darwin "<path>/$(<project>_installarea_prefix)/${CMTCONFIG}/lib"

cmtpath_pattern \
    path_remove  ROOT_INCLUDE_PATH "<path>/$(<project>_installarea_prefix)/root-include-path" ; \
    path_prepend ROOT_INCLUDE_PATH "<path>/$(<project>_installarea_prefix)/root-include-path"

#-------------------------------------------------------------
# Simple patterns (to be applied on demand only)
#-------------------------------------------------------------


#--------------------------------------------
pattern default_rpath \
  path_remove LD_LIBRARY_PATH "/<package>/"

#
#  Defines a shared library access path in the binary directory of the package
#

#--------------------------------------------
pattern default_library_path \
  path_remove LD_LIBRARY_PATH "/<package>/"

#
#  Defines a shared library access path in the binary directory of the package
#
#--------------------------------------------
pattern default_linkopts \
  macro <package>_linkopts "-L$(<PACKAGE>ROOT)/$(<package>_tag) -l<package> <extras> " \
	UnixStatic "$(<PACKAGE>ROOT)/$(<package>_tag)/lib<package>.a <extras> " ; \
  apply_pattern default_rpath
#
#  To be applied when one shared library named after the package name is provided
#     extras=<additional linker options>
#


#--------------------------------------------
pattern default_no_share_linkopts \
  macro <package>_linkopts "-L$(<PACKAGE>ROOT)/$(<package>_tag) -l<package> <extras> " \
	UnixStatic "$(<PACKAGE>ROOT)/$(<package>_tag)/lib<package>.a <extras> "
#
#  To be applied when one static library named after the package name is provided
#     extras=<additional linker options>
#

#--------------------------------------------
pattern installed_linkopts \
  macro_append <package>_library_dependencies " <package>" ; \
  private ; \ 
    macro <package>_shlibflags          "" notAsNeeded "" asNeeded "$(libraryshr_linkopts) $(cmt_installarea_linkopts) $(<package>_use_linkopts) $(<package>_extra_shlibflags)" ; \
    macro_remove <package>_use_linkopts "" notAsNeeded "" asNeeded "$(<package>_linkopts)" ; \
  end_private ; \
  macro <package>_linkopts "-l<package> <extras> " \
	UnixStatic "$(<PACKAGE>ROOT)/$(<package>_tag)/lib<package>.a <extras> "
#
#  to be applied when one library is provided by the package, and when
#  this library is expected to be installed as a symbolic link in client packages
#
#  the macro <package>_libraries will have to be specified
#

#--------------------------------------------
pattern default_library \
  library <package> *.cxx ; \
  apply_pattern default_linkopts ; \
  apply_pattern optdebug_library name=<package>
#
#  very basic pattern for the simplest case, where one shared library only composed of
#  C++ source files in ../src is provided by the package
#


#--------------------------------------------
pattern default_installed_library \
  library <package> *.cxx ; \
  apply_pattern installed_library ; \
  apply_pattern optdebug_library name=<package>
#
#  same pattern as default_library except that the minimal library will be installed
#  in client packages
#


#--------------------------------------------
pattern no_include_path \
  ignore_pattern default_include_path ; \
  include_path none
#
#  To be applied when a package does not provide any header file
#  (typical for interface packages)
#

#--------------------------------------------
pattern include_path \
  ignore_pattern default_include_path ; \
  include_dirs <extras>
#
#   Short cut for specifying several header search paths.
#

#--------------------------------------------
# Specific patterns for installing various kinds of files to the installation area.
#
#--------------------------------------------

pattern declare_joboptions \
    apply_pattern generic_declare_for_link kind=joboptions files='-s=../share <files>' prefix=jobOptions/<package> name=<name>

pattern declare_python_modules \
    apply_pattern generic_declare_for_link kind=python_modules files='-s=../python <files>' prefix=python/<package> name=<name> ; \
    private ; \
    macro_append <package>_python_init_dependencies " install_<name>python_modules " ; \
    end_private

# <package>_python_init constituent (python_init document from GaudiPolicy)
# installs default __init__.py for <package> if not yet installed by <package>
# this is to ensure that <package> __init__.py installation runs first

pattern declare_runtime \
    apply_pattern generic_declare_for_link kind=runtime files='-s=../share <files> <extras>' prefix=share name=<name>

pattern declare_runtime_extras \
    apply_pattern declare_runtime files="<files>" extras="<extras>" name="<name>"

pattern install_runtime \
    macro data "$(use_runtime)" ; \
    document get_files <name>get_files install_dir=../run/ copymethod=<method>

pattern declare_scripts \
    apply_pattern generic_declare_for_link kind=scripts files='-s=../share <files>' prefix=share/bin name=<name>

pattern declare_xmls \
    apply_pattern generic_declare_for_link kind=xmls files='-s=../data *.dtd *.xml <extras>' prefix=XML/<package> name=<name>

pattern install_xmls

pattern declare_java \
    macro_append <package>_java " $(<package>_root)/java/*.jar" ; \
    macro_append use_java " $(<package>_java) "

pattern install_java \
    path_remove  CLASSPATH "/<package>/java" ; \
    path_prepend CLASSPATH "${<PACKAGE>ROOT}/java" ; \
    apply_pattern generic_declare_for_link kind=java files='-s=../java *.jar' prefix=java name=<name>

pattern declare_docs \
    apply_pattern generic_declare_for_link kind=docs files='-s=../doc <files>' prefix=doc/<package> name=<name>

#--------------------------------------------
# Pattern to apply the get_files command through make
#--------------------------------------------
make_fragment get_files -header=get_files_header

pattern get_files \
    macro <name>jo "<jo>" ; \
    macro <name>scripts "<scripts>" ; \
    macro <name>data "<data>" ; \
    macro <name>xmls "<xmls>" ; \
    document get_files <name>get_files install_dir=../run/ copymethod=<method> name=<name>



#--------------------------------------------
# Patterns for Gaudi.
#
#   Principles:
#
#   o We consider 
#       IASvc    : Abstract interface to a component
#       ASvc     : Implementation of the component
#       B        : A client of this component
#
#  ASvc should use IASvc
#  B    should use ASvc (and gets IASvc from it)
#
#  IASvc :
#    provide -I
#    has no -L
#
#  ASvc
#    has no -I (but those inherited from IASvc)
#    has no -L
#    export LD_LIBRARY_PATH
#    needs <package>_shlibflags as $(use_linkopts)
#
#--------------------------------------------

pattern shared_library \
   macro <package>_linkopts "-L$(<PACKAGE>ROOT)/$(<package>_tag) -l<package> <extras> " ; \
   path_remove LD_LIBRARY_PATH "/<package>/" ; \
   apply_pattern optdebug_library name=<package>

pattern static_library \
   macro <package>_linkopts "-L$(<PACKAGE>ROOT)/$(<package>_tag) -l<package> <extras> " \
	UnixStatic "$(<PACKAGE>ROOT)/$(<package>_tag)/lib<package>.a <extras>" ; \
   macro_append <package>_stamps " $(<package>_root)/$(<package>_tag)/<package>.stamp" ; \
   apply_pattern optdebug_library name=<package>

pattern installed_library \
   macro_append <package>_installed_dependencies " <package>" ; \
   macro_append <package>_library_dependencies   " <package>" ; \
   macro_append <package>_installed_shlibflags "" notAsNeeded "" asNeeded " -l<package> " ; \
  private ; \ 
    macro <package>_shlibflags          "" notAsNeeded "" asNeeded "$(libraryshr_linkopts) $(cmt_installarea_linkopts) $(<package>_use_linkopts) $(<package>_extra_shlibflags)" ; \
    macro_remove <package>_use_linkopts "" notAsNeeded "" asNeeded "$(<package>_linkopts)" ; \
  end_private ; \
   macro_append <package>_linkopts " -l<package> <extras> " \
	UnixStatic " $(<PACKAGE>ROOT)/$(<package>_tag)/lib<package>.a <extras>" ; \
   apply_pattern optdebug_library name=<package>

pattern named_installed_library \
   macro_append <package>_library_dependencies " <library>" ; \
   macro_append <library>_dependencies         " $(<package>_installed_dependencies)" ; \
  private ; \ 
    macro <library>_installed_shlibflags "" notAsNeeded "" asNeeded " $(<package>_installed_shlibflags) " ; \
    macro <library>_shlibflags           "" notAsNeeded "" asNeeded "$(libraryshr_linkopts) $(cmt_installarea_linkopts) $(<library>_installed_shlibflags) $(<library>_use_linkopts) " ; \
    macro_remove <library>_use_linkopts  "" notAsNeeded "" asNeeded "$(<package>_linkopts)" ; \
  end_private ; \
   macro_append <package>_linkopts " -l<library> <extras> " \
	UnixStatic " $(<PACKAGE>ROOT)/$(<package>_tag)/lib<library>.a <extras>" ; \
   apply_pattern optdebug_library name=<library>

pattern component_interface

#pattern component_implementation \
#   ignore_pattern default_include_path ; \
#   macro <package>_shlibflags "$(componentshr_linkopts) $(use_linkopts) " ; \
#   set <package>Shr "${<PACKAGE>ROOT}/${CMTCONFIG}/lib<package>"

##
## Due to mismatch between this definition of the component_library pattern
## and the one from GaudiPolicy, it's needed to add a reference to the <library>
## argument. This trick might disappear in some future.
##
pattern component_library_no_genCLIDDB \
   macro_append <package>_library_dependencies " <package>" ; \
   macro_append <package>_linkopts "" \
	UnixStatic " $(<PACKAGE>ROOT)/$(<package>_tag)/lib<package>.a -u <package>_loadRef " ; \
   macro <package>_shlibflags "$(componentshr_linkopts) $(<package>_use_linkopts) " ; \
   macro_append <package>_extra_shlibflags " -l<package>" ; \
   private ; \
     use GaudiKernel v* -no_auto_imports ; \
     macro dummy_for_library "<library>" ; \
     macro <package>_genconfig_cmd "generate_configurables" no_genconf "do_null_genconfig" ; \
     apply_pattern $(<package>_genconfig_cmd) library=<package> ; \
     apply_pattern generate_componentslist library=<package> group=<group> ; \
   end_private ; \
   apply_pattern optdebug_library name=<package>

pattern component_library \
   apply_pattern component_library_no_genCLIDDB library=<library> group=<group> ; \
   private ; \
     apply_pattern do_genCLIDDB library=<package> ; \
   end_private

pattern named_component_library \
   macro_append <package>_library_dependencies " <library>" ; \
   macro_append <package>_linkopts "" \
	UnixStatic " $(<PACKAGE>ROOT)/$(<package>_tag)/lib<library>.a -u <library>_loadRef " ; \
   macro <library>_shlibflags "$(componentshr_linkopts) $(<library>_use_linkopts) " ; \
   macro_append <package>_extra_shlibflags " -l<library>" ; \
   macro_append <package>_named_libraries "<library> " ; \
   private ; \
     use GaudiKernel v* -no_auto_imports ; \
     apply_pattern generate_configurables library=<library> ; \
     apply_pattern generate_componentslist library=<library> group=<group> ; \
     apply_pattern do_genCLIDDB library=<library> ; \
   end_private ; \
   apply_pattern optdebug_library name=<library>

# This pattern is similar to the component_library pattern in that the library is built by
# linking against all dependent libraries, but it doesn't perform a generate_configurables. 
pattern linked_library \
   macro_append <package>_library_dependencies " <package>" ; \
   macro_append <package>_linkopts "" \
	UnixStatic " $(<PACKAGE>ROOT)/$(<package>_tag)/lib<package>.a -u <package>_loadRef " ; \
   macro <package>_shlibflags "$(componentshr_linkopts) $(<package>_use_linkopts) " ; \
   macro_append <package>_extra_shlibflags " -l<package>" ; \
   apply_pattern optdebug_library name=<package>

pattern named_linked_library \
   macro_append <package>_library_dependencies " <library>" ; \
   macro_append <package>_linkopts "" \
	UnixStatic " $(<PACKAGE>ROOT)/$(<package>_tag)/lib<library>.a -u <library>_loadRef " ; \
   macro <library>_shlibflags "$(componentshr_linkopts) $(<library>_use_linkopts) " ; \
   macro_append <package>_extra_shlibflags " -l<library>" ; \
   macro_append <package>_named_libraries "<library> " ; \
   apply_pattern optdebug_library name=<library>

pattern dual_use_library \
   macro <package>Lib_files "<files>" ; \
   library <package>Lib -import=<imports> $(<package>Lib_files) ; \
   library <package> -import=<imports> components/*.cxx ; \
   macro_append <package>_library_dependencies " <package> <package>Lib" ; \
   macro_append <package>_dependencies " <package>Lib" ; \
   macro_append <package>stamps " $(<PACKAGE>ROOT)/$(<package>_tag)/<package>Lib.stamp " ; \
   macro_append <package>_linkopts " -l<package>Lib" \
     UnixStatic " $(<PACKAGE>ROOT)/$(<package>_tag)/lib<package>.a -u <package>_loadRef $(<PACKAGE>ROOT)/$(<package>_tag)/lib<package>Lib.a " ; \
  private ; \ 
    macro <package>Lib_shlibflags       "" notAsNeeded "" asNeeded "$(libraryshr_linkopts) $(cmt_installarea_linkopts) $(<package>Lib_use_linkopts)" ; \
    macro_remove <package>Lib_use_linkopts "" notAsNeeded "" asNeeded "$(<package>_linkopts)" ; \
  end_private ; \
   macro <package>_shlibflags "$(componentshr_linkopts) $(<package>_use_linkopts) " ; \
   macro_append <package>_extra_shlibflags " -l<package>" ; \
   private ; \
     use GaudiKernel v* -no_auto_imports ; \
     apply_pattern generate_configurables library=<package> ; \
     apply_pattern generate_componentslist library=<package> group=<group> ; \
     apply_pattern do_genCLIDDB library=<package> ; \
   end_private ; \
   apply_pattern optdebug_library name=<package> ; \
   apply_pattern optdebug_library name=<package>Lib

pattern named_dual_use_library \
   macro <library>Lib_files "<files>" ; \
   library <library>Lib -import=<imports> $(<library>Lib_files) ; \
   library <library> -import=<imports> components/*.cxx ; \
   macro_append <package>_library_dependencies " <library> <library>Lib" ; \
   macro_append <library>_dependencies " <library>Lib" ; \
   macro_append <library>stamps " $(<PACKAGE>ROOT)/$(<package>_tag)/<library>Lib.stamp " ; \
   macro_append <package>_linkopts " -l<library>Lib" \
     UnixStatic " $(<PACKAGE>ROOT)/$(<package>_tag)/lib<library>.a -u <library>_loadRef $(<PACKAGE>ROOT)/$(<package>_tag)/lib<library>Lib.a " ; \
  private ; \ 
    macro <library>Lib_shlibflags       "" notAsNeeded "" asNeeded "$(libraryshr_linkopts) $(cmt_installarea_linkopts) $(<library>Lib_use_linkopts)" ; \
    macro_remove <library>Lib_use_linkopts "" notAsNeeded "" asNeeded "$(<package>_linkopts)" ; \
  end_private ; \
   macro <library>_shlibflags "$(componentshr_linkopts) $(<library>_use_linkopts) " ; \
   macro_append <package>_extra_shlibflags " -l<library>" ; \
   private ; \
     use GaudiKernel v* -no_auto_imports ; \
     macro_append <package>_named_libraries "<library> " ;\
     apply_pattern generate_configurables library=<library> ; \
     apply_pattern generate_componentslist library=<library> group=<group> ; \
     apply_pattern do_genCLIDDB library=<library> ; \
   end_private ; \
   apply_pattern optdebug_library name=<library> ; \
   apply_pattern optdebug_library name=<library>Lib

#----------------------------------------------
# generate T/P cnv entries
#----------------------------------------------
#macro abuild_gen_tpcnv_cmd $(AtlasPolicy_root)/scripts/abuild-gen-tpcnvdb.py
macro abuild_gen_tpcnv_cmd true

pattern named_tpcnv_library \
   apply_pattern named_installed_library library=<library> ; \
   private ; \
      apply_pattern generate_componentslist library=<library> group=<group> ; \
   end_private
 
pattern tpcnv_library \
   apply_pattern installed_library ; \
   private ; \
      apply_pattern generate_componentslist library=<package> group=<group> ; \
   end_private

#----------------------------------------------
   
pattern application_path \
   path_remove PATH "/<package>/"

pattern application_alias \
   alias <application> "<application>.exe"

pattern declare_applications

pattern install_applications

pattern static_app \
    application <name>Static -group=static <sources> <imports>

pattern static_athena_app \
    macro static_Athena "" static "AthenaCommon AthenaCommon-* Control" ; \
    use $(static_Athena) ; \
    application <package>Static -group=static ${ATHENACOMMONROOT}/src/AthenaMain.cxx <imports>

# DRQ: The following patterns implement conditional dependencies based on 
# the "static" tag. No dependency is introduced apart from when the
# static tag is applied. The useage is:
#
# apply_pattern static_use use=Pkg container=Ctr
#   or
# apply pattern use_static_version use=Pkg ver=Ver container=Ctr
#
# Note the less than ideal arguments are due to the fact that "package"
# and "version" are CMT-reserved.
pattern static_use_version \
    macro use_<use> "" static "<use> <vers> <container>" ; \
    use $(use_<use>)

pattern static_use \
    macro use_<use> "" static "<use> * <container>" ; \
    use $(use_<use>)

#--------------------------------------------
# Other definitions
#--------------------------------------------

macro_append constituents "" static " static"

make_fragment empty_header

make_fragment ps2pdf -header=empty_header -suffix=pdf
make_fragment tex2html -header=empty_header -suffix=html

macro_append MAKEFLAGS " --no-print-directory "

tag insure Linux
tag insure i386_linux22

#----------------------------------------------
# generate clid db
#----------------------------------------------

macro genCLIDDB_cmd  ${AtlasPolicy_root}/cmt/fragments/gencliddb.py
make_fragment genCLIDDB -header=genCLIDDB_header

macro use_CLIDComps "CLIDComps * Control -no_auto_imports" no_genCLIDDB ""

pattern do_genCLIDDB \
  private ; \
     use $(use_CLIDComps) ; \
     macro run_genCLIDDB "do_real_genCLIDDB" \
	   no_genCLIDDB  "do_null_genCLIDDB" ; \
     apply_pattern $(run_genCLIDDB) library=<library>  ; \
  end_private 
 
pattern do_real_genCLIDDB \
  private ; \
    document genCLIDDB <library>CLIDDB library=<library>  ; \
    macro_append <library>CLIDDB_dependencies " <library> " ; \
    macro_append <library>ComponentsList_dependencies " <library>CLIDDB " ; \
  end_private

pattern do_null_genCLIDDB \
  private ; \
     macro dummy_for_<library>CLIDDB "<library>" ; \
  end_private

#----------------------------------------------
# Patterns and skelettons for Gaudi component stub generation
#----------------------------------------------

# Skeletton for creating <package>_load.cxx
make_fragment gaudi_load

# Skeletton for creating <package>_entries.cxx
make_fragment gaudi_open_entries
make_fragment gaudi_entries
make_fragment gaudi_close_entries

# Skelettons for each component type
make_fragment gaudi_algorithm
make_fragment gaudi_service
make_fragment gaudi_converter
make_fragment gaudi_object

# Document generator for instanciating the stubs
make_fragment gaudi_generator -header=gaudi_generator_header

# Pattern applying stub generation for both load and entries modules
pattern gaudi_dll_generator \
  macro gaudi_load_model  "'<gaudi_load module=$(package)/>'" ; \
  macro gaudi_entries_model "'<gaudi_entries module=$(package)/><gaudi_open_entries/>$(extra_entries)<gaudi_close_entries/>'" ; \
  document gaudi_generator gaudi_load model="$(gaudi_load_model)" out=$(src)$(package)_load.cxx ; \
  document gaudi_generator gaudi_entries model="$(gaudi_entries_model)" out=$(src)$(package)_entries.cxx ; \
  macro <package>_dll_dependencies gaudi_load gaudi_entries ; \
  library <package>_dll <package>_load.cxx <package>_entries.cxx



#--------------------------------------------
#
# Remote launcher facility.
#
#  Supply synchronous and asynchronous remote launcher
#
#  Possible parameters:
#
#   remote_launcher   : the command for remote invocation
#   remote_sites      : the list of remote sites
#   remote_action     : the action to launch
#
#--------------------------------------------

macro remote_launcher "ssh -f "

make_fragment launcher_sync_header
make_fragment launcher_sync -header=launcher_sync_header

make_fragment launcher_async_header
make_fragment launcher_async -header=launcher_async_header

#--------------------------------------------
#
#  This pattern is a temporary work-around for a limitation in CMT:
#
#  It is impossible nowadays to trigger the rebuild of a shared library
#  when it includes static libraries from other packages. (especially
#  when they have been changed without any modification to their
#  public interface)
#
#   This mechanism exists for application but not for shared libraries.
#
#--------------------------------------------

make_fragment libdeps -header=libdeps_header

pattern libdeps \
  document libdeps <library>deps library=<library> ; \
  macro_append <library>_dependencies " <library>deps "

#--------------------------------------------
#
#  This pattern is a prototype unit test for "make check"
#
#--------------------------------------------

make_fragment athena_launcher_header
make_fragment athena_launcher -header=athena_launcher_header

pattern athena_test \
    document athena_launcher <name>_test -group=check \
    	athena_exe="'../${CMTCONFIG}/athena.exe'" \
	athena_opt="<options>" \
	athena_pre="'if test -f <name>.log ; \
                     then /bin/rm -f <name>.log; fi'" \
	athena_rem="<remove>" \
	athena_out="' >& <name>.log'" \
	athena_post="'if ! test -f ../baseline/<name>.log ; \
                       then mv <name>.log ../baseline ; \
                       else diff <name>.log ../baseline/<name>.log; fi'"

##pattern -global no_config_variable set <PACKAGE>CONFIG ""

#--------------------------------------------
#
#  Patterns and definitions for install area management.
#
#     Discard the mechanism temporarily
#     It can be activated manually be activating the "installarea" tag
#
#--------------------------------------------

## This detects and creates installation areas when needed (and when possible)
## It also sets the proper value for the current installation area which 
## actually corresponds to the first item in the CMTPATH list 
##
##  Setting this variable to empty string completely discards the mechanism

###macro install_command "$(install_command)"
macro cmt_install_area_command   "$(symlink_command)"
macro cmt_uninstall_area_command "$(uninstall_command)"

#--------------------------------------------
## Overridden CMT make fragments to support automatic installation  
## of libraries and applications. Those fragments should eventually
## return to core CMT (if they are proven to be project independent)
#
# It's the case from CMT v1r18
#--------------------------------------------

#macro application_fragment "application" CMTr18 ""
#make_fragment $(application_fragment)

#macro library_fragment "library" CMTr18 ""
# library_no_static fragment from core CMT (renamed as library)
# to allow for shared library only to be built by default
# (instead of shared + static libraries)
# to disable this fragment/behaviour, activate tag WithStatic
#  following lines have moved to AtlasCommonPolicy
#tag static WithStatic
#tag UnixStatic WithStatic
#macro library_fragment "library" WithStatic ""
#make_fragment $(library_fragment)

# slightly modified fragment from core CMT to allow for
# obsolete objects to be excluded from the static library
# ar macro to be overridden with libtool -o on Mac OS X
#make_fragment library

#macro library_no_share_fragment "library_no_share" CMTr18 ""
#make_fragment $(library_no_share_fragment)

## Overridden CMT make fragments with a fix (from the CMT HEAD)
make_fragment cmt_action_runner -header=cmt_action_runner_header
make_fragment cmt_action_runner_header

## Overridden CMT make fragments
# another way to address https://savannah.cern.ch/bugs/?72935
make_fragment cleanup_header

#--------------------------------------------
## Overridden CMT make fragments to overcome the limitation
## on dependency discovery. With that patch, the incremental build
## should be aware of underlying changes of header files not implying any
## chage in the dates
#--------------------------------------------

# Protection against macro build_dependencies overrides
# incompatible with the modified CMT v1r24 and later dependencies fragment
# see, e.g., tdaq/tdaq-04-00-01/TDAQPolicy
# assume that releases older than CMTr20 not used
macro dependencies_fragment "dependencies" CMTr23 "" CMTr22 "" CMTr21 "" CMTr20 ""
make_fragment $(dependencies_fragment)

macro make_header_fragment "" CMTr18 "" CMTr16 "make_header"
make_fragment $(make_header_fragment)

#--------------------------------------------
## Those two make fragments are simple patches to be applied onto v1r14 
## (to cure bugs in install mechanisms)
## Once CMTv1r14 is patched, then they may disappear...
##make_fragment constituent
#--------------------------------------------
#make_fragment constituents_trailer

#--------------------------------------------
## Make fragments for automatic installation of header files in the
## current installation area.
#--------------------------------------------

make_fragment install_includes -header=install_includes_header
make_fragment install_includes_header
make_fragment install_named_includes -header=install_named_includes_header
make_fragment install_named_includes_header

make_fragment install_root_include_path -header=install_root_include_path_header
make_fragment install_root_include_path_header

##   macro_prepend use_includes   " $(ppcmd)<path>/$(cmt_installarea_prefix)/include "

#--------------------------------------------
## Automating the installation of header files
## This is currently applied on demand using 'gmake install_headers'
## we might consider making it systematic
##  (the pattern is to non global temporarily)
##
#--------------------------------------------

macro install_include_filter "*.h"

pattern install_non_standard_includes \
  document install_named_includes install_<name>_includes name=<name> ; \
  macro_prepend constituents " install_<name>_includes " ; \
  macro_append <package>_include_dirs " <name> "

#--------------------------------------------
# The following tag is explicitly activated to declare that The new scheme based
# on the AthenaRunTime package is now in place.
#--------------------------------------------

apply_tag HasAthenaRunTime

#--------------------------------------------
# Private section
#--------------------------------------------

private

macro AtlasPolicy_pacman_hints "AtlasPolicy.pacman"

end_private

apply_pattern declare_scripts files="checkreq.py"

action checkreq "checkreq.py -i 2 -n" 

# macro_append all_dependencies " checkreq "

private

action checkreq "true"

end_private


#--------------------------------
# PathResolver (calibration file finding) section
#--------------------------------
#pattern for installing calibration files 
pattern declare_calib \
   apply_pattern generic_declare_for_link files="<files>" kind=calib prefix="share/<package>" name="<name>"


#---------------------------------
# ManaCore and AthSimulationBase section
#---------------------------------
#action checkreq "checkreq.py -i 2 -n" ManaCore " echo 'CHECKREQ: checkreq disabled in ManaCore releases' "
macro_append pp_cppflags "" ManaCore " -DXAOD_MANACORE -DXAOD_ANALYSIS "
macro_append pp_cppflags "" AthSimulationBase " -DSIMULATIONBASE "

pattern use_ifndef \
    public ; \
    macro <package>_pplist_<pkg> "`echo "<pplist>" | sed 's/,/\|/g'`" ; \
    macro <package>_check_statement_<pkg> "`echo $(pp_cppflags)|egrep -q '\-D(($(<package>_pplist_<pkg>))( |$|=))' &&echo <package>_<pkg>_hasPP||echo <package>_<pkg>_nothasPP`" ; \
    apply_tag $(<package>_check_statement_<pkg>) ; \
    macro <package>_use_statement_<pkg> "`basename "<pkg>"` `basename "<pkg>"`-* `dirname "<pkg>"`" <package>_<pkg>_hasPP "" ; \
    end_public ; \
    use $(<package>_use_statement_<pkg>) 
