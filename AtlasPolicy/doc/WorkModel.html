<html>
  <head>
    <title>How to develop using CMT</title>
    <!-- Changed by: Christian Arnault, 18-Jul-2001 -->
  </head>
  <body>

    <center><h1>How to develop using CMT</h1></center>

    <ol>
      <li><h2><a href="#Introduction">Introduction</a></h2></li>
      <li><h2><a href="#Setup CMTtup CMT</a></h2></li>
      <li><h2><a href="#Create a test release and checkout packages">Create a test release and checkout packages</a></h2></li>
      <li><h2><a href="#Setup the CMTPATH search path">Setup the CMTPATH search path</a></h2></li>
      <li><h2><a href="#Building (compiling and linking) a single package">Building (compiling and linking) a single package</a></h2></li>
      <li><h2><a href="#Building (compiling and linking) multiple packages">Building (compiling and linking) multiple packages</a></h2></li>
      <li><h2><a href="#Establishing a run-time environment">Establishing a run-time environment</a></h2></li>
      <li><h2><a href="#Specifying dependencies between packages">Specifying dependencies between packages</a></h2></li>
      <li><h2><a href="#Standard Patterns">Standard Patterns</a></h2></li>

      <ol>
	<li><h3><a href="#Component Library">Component Library</a></h3></li>
	<li><h3><a href="#Linker Library">Linker Library</a></h3></li>
	<li><h3><a href="#Application">Application</a></h3></li>
      </ol>

      <li><h2><a href="#Not yet compiled comments">Not yet compiled comments</a></h2></li>
    </ol>

    <hr></hr>
    <h1><a name="Introduction"></a>Introduction</h1>

    <blockquote>

      <p>The model of development using CMT is rather similar to that when
	using SRT, although many of the details are different. The basic model
	is to create a test release, into which the package or packages under
	development can be checkout from CVS, modified, tested and later
	checked back into CVS.</p>
      
      <p>This note describes first how to create a test release, how to develop
	within one, for the situations where a single or multiple packages
	have been checked out, and how to establish a run-time environment for
	performing testing.</p>
      
      <p>The other important scenario which will be addressed later on
	describes how to work out a bug fix to be applied to an already tagged
	and published version of a package.</p>
      
      <blockquote>
	<i>The contents of this note will be subject to modifications,
	  at least in the short term, until the conventions described
	  here become stable. We expect such tuning to occur especially
	  in the early days of the migration towards CMT. Therefore
	  please do not consider the conventions or suggestions
	  described in this document as being yet the final and
	  definitive Atlas policy.
	  
	  <p>Moreover, the feedback and contributions from users are
	    highly welcome so as to construct as efficiently as possible
	    the work model and policy.</p>
	  
	</i>
      </blockquote>
      
    </blockquote>

    <hr></hr>
    <h1><a name="Setup CMT"></a>Setup CMT</h1>
    <blockquote>

    <p>Setup CMT within your login environment:</p>

    <p>For Bourne-style shells [sh, zsh, bash]</p>

    <pre>
    export CMTBASE=/afs/cern.ch/sw/contrib/CMT     [1]
    export CMTVERS=v1r9                            [2]
    export CMTSITE=CERN                            [3]
    export CMTCVSOFFSET offline                    [4]
    source $CMTBASE/$CMTVERS/mgr/setup.sh          [5]
    </pre>

    <p>For C-style shells [csh, tcsh]</p>

    <pre>
    setenv CMTBASE /afs/cern.ch/sw/contrib/CMT     [1]
    setenv CMTVERS v1r9                            [2]
    setenv CMTSITE CERN                            [3]
    setenv CMTCVSOFFSET offline                    [4]
    source $CMTBASE/$CMTVERS/mgr/setup.csh         [5]
    </pre>

    <p>Notes:</p>
    
    <ol>

      <li>The CMTBASE environment variable should be set to the location
	of the CMT installation for your site. The example above is
	appropriate for CERN.</li>

      <li> The CMTVERS environment variable should be set to the current
	version of CMT.</li>

      <li> The CMTSITE environment variable should be set to a value
	approriate for your site. The example above is appropriate for
	CERN.</li>

      <li> The CMTCVSOFFSET environment variable specifies an offset
	within the CVS repository and avoids some typing.</li>

      <li> This sets up the CMT environment including the cmt command.</li>

    </ol>

    </blockquote>

    <hr></hr>
    <h1><a name="Create a test release and checkout packages"></a>Create a test release and checkout packages</h1>
    <blockquote>

      <p>Decide on the location of your test release and create a
	suitable directory if one doesn't already exist:</p>

      <pre>
&gt; mkdir &lt;dir&gt;
&gt; cd &lt;dir&gt;
      </pre>

      <p>Checkout the desired packages from CVS. It is recommended
	that CMT is used to do this since that will ensure that the
	correct directory hierarchy is created:</p>

      <pre>
&gt; cmt co [-r <tag>] &lt;pkg&gt;
      </pre>

      <p>e.g.</p>

      <pre>
&gt; cmt co Generators/GeneratorModules                              [1]
&gt; cmt co -r GeneratorModules-00-00-30 Generators/GeneratorModules [2]
      </pre>

      <p>Notes:</p>

      <ol>

	<li>This checks out the package from the head of CVS.</li>

	<li> This checks out the specified tag of the package.</li>

	<li> If the CMTCVSOFFSET environment variable hadn't been setup, the
	  commands would have had to have been of the form:

	  <pre>
&gt; cmt co offline/Generators/GeneratorModules
	  </pre>

	  <p>and another tier in the directory hierarchy (offline/)
	    would be created.</p>

	</li>

      </ol>

    </blockquote>

    <hr></hr>
    <h1><a name="Setup the CMTPATH search path"></a>Setup the CMTPATH search path</h1>
    <blockquote>

      <p>The CMTPATH search path is used by CMT to bind together
	partial releases. In this case it is used to bind together the
	test release and the underlying base releases. In the
	following example, the names of the environment variables have
	no particular significance, they are just a convenience:</p>

      <pre>
&gt; export CMTTEST=<dir>
&gt; export CMTATLAS=/afs/cern.ch/atlas/software/dist/ART_Evaluations/ReleasesWithCMT
&gt; export CMTGAUDI=/afs/cern.ch/atlas/offline/external/Gaudi/0.7.2
&gt; export CMTPATH=${CMTTEST}:${CMTATLAS}:${CMTGAUDI}
      </pre>

      <p>or</p>

      <pre>
&gt; setenv CMTTEST <dir>
&gt; setenv CMTATLAS /afs/cern.ch/atlas/software/dist/ART_Evaluations/ReleasesWithCMT
&gt; setenv CMTGAUDI /afs/cern.ch/atlas/offline/external/Gaudi/0.7.2
&gt; setenv CMTPATH ${CMTTEST}:${CMTATLAS}:${CMTGAUDI}
      </pre>


      <p>Any package that appears in an upstream fragment of CMTPATH
	will hide the equivalent package in a downstream fragment. The
	first fragement is generally the location of the test release,
	the second in this case is the main ATLAS release, and the
	third is the Gaudi release that Athena is based
	on. Potentially other partial releases could be present in the
	search path, but this is the current minimal configuration.</p>

    </blockquote>

    <hr></hr>
    <h1><a name="Building (compiling and linking) a single package"></a>Building (compiling and linking) a single package</h1>
    <blockquote>

      <p>Go to the cmt directory within the package to be developed:</p>

      <pre>
&gt; cd &lt;dir&gt;/&lt;pkg&gt;/&lt;tag&gt;/cmt
      </pre>

      <p>where &lt;pkg&gt; is the package name
	(e.g. Generator/GeneratorModules) and &lt;tag&gt; is the tag
	(e.g. GeneratorModules-00-00-30). The relevant commands for
	compiling and linking this package are:</p>

      <pre>
&gt; cmt config     [1]
&gt; gmake clean    [2]
&gt; gmake          [3]
      </pre>

      <p>Notes:</p>

      <ol>

	<li> This is the equivalent of "../src/configure" in the SRT
	  world and only needs to be done if there is a change in the
	  dependencies.</li>

	<li> This is the equivalent of "gmake clean" in the SRT world.</li>

	<li> This is the equivalent of "gmake install" in the SRT
	  world. There is no equivalent to the SRT installation phase.</li>

      </ol>

    </blockquote>

    <hr></hr>
    <h1><a name="Building (compiling and linking) multiple packages"></a>Building (compiling and linking) multiple packages</h1>

    <blockquote>

      <p>If multiple packages are checked out within the test release,
	it is possible that there are no direct dependencies between
	them. One could either treat them as multiple independent
	packages and build them all separately as discussed above, or
	you can setup an environment to allow you to build them all
	together. The easiest way of doing this is to create a
	pseudo-package alongside the actual packages in your test
	release, and to create a requirements file in that
	pseudo-package. For example:</p>

      <pre>
&gt; cd &lt;dir&gt;
&gt; mkdir TestRelease
&gt; mkdir TestRelease/cmt
&gt; cd TestRelease/cmt
&gt; cat &gt; requirements

use GeneratorModules GeneratorModules-* Generators
[etc.]
Ctrl-D
      </pre>

      <p>Then the cmt commands for configuring and building these packages are:</p>

      <pre>
&gt; cmt broadcast cmt config
&gt; cmt broadcast gmake clean
&gt; cmt broadcast gmake
      </pre>

      <p>The "cmt broadcast" command broadcasts the specified commands
	to all packages in the first fragment of the $CMTPATH, which
	in this case is your test release.</p>

    </blockquote>

    <hr></hr>
    <h1><a name="Establishing a run-time environment"></a>Establishing a run-time environment</h1>

    <blockquote>

      <p>CMT provides mechanisms for creating a run-time
	environment. Within the cmt directory of each package are
	files setup.csh and setup.sh. A run-time environment can be
	established simply by:</p>

      <pre>
&gt; source setup.sh
      </pre>

      <p>or</p>

      <pre>
&gt; source setup.csh
      </pre>

      <p>Note however that the run-time environment is not necessarily
	the same as that established by the normal package
	dependencies. For example, in order to establish the athena
	run-time environment, it is necessary that a dependency to the
	Control/AthenaCommon package exists. This might not be the
	case for any of the packages that are being developed. In this
	case, the easiest way of establishing a run-time environment
	is to extend the requirements file used to control building
	packages within the test release, by adding the relevant "use"
	statements for the packages that are also necessary for
	establishing the run-time environment:</p>

      <pre>
&gt; cd &lt;dir&gt;/TestRelease/cmt
&gt; cat &gt; requirements

use GeneratorModules GeneratorModules-* Generators
[etc.]
use AthenaCommon AthenaCommon-* Control
Ctrl-D
      </pre>

      <p>Then the commands for establishing a run-time environment are:</p>

      <pre>
&gt; cmt config
&gt; gmake                         [1]
&gt; source setup.[c]sh            [2]
      </pre>

      <p>Notes:</p>

      <ol>

	<li> It is important that "gmake" is run on this package, in
	  case library symbolic links need to be established.</li>

	<li> This command sets up the run-time environment.</li>

      </ol>

      <p>Note that the same directory can be used to control building
	of the test release and the establishment of a run-time
	environment.</p>

    </blockquote>

    <hr></hr>
    <h1><a name="Specifying dependencies between packages"></a>Specifying dependencies between packages</h1>

    <blockquote>

      <p>Dependencies between package are specified through "use"
	statements within the requirements files. Such statements also
	specify the versions of the packages, although wildcards can
	be used to weaken the relationship. ATLAS recommends the
	following relationships:</p>

      <ul>

	<li>A. General dependencies between one package and another
	  should be expressed in the form of:

	  <pre>
use OtherPackage OtherPackage-00-* OtherPackageParent
	  </pre>

	  e.g.

	  <pre>
use GeneratorModules GeneratorModules-00-* Generators
	  </pre>

	</li>

	<li>B. Container packages should depend upon the exact
	  versions of their children packages. Thus the Generators
	  package should list its children using the format:

	  <pre>
use GeneratorModules-00-00-31 Generators
use GeneratorObjects-00-00-31 Generators
[etc.]
	  </pre>

	</li>

      </ul>

    </blockquote>

    <hr></hr>
    <h1><a name="Standard Patterns"></a>Standard Patterns</h1>

    <blockquote>

      <p>Several standard patterns have been created to ease the job
	of the package writer. They cover the situation for most
	standard packages; those that create linker or component
	libraries, or applications.</p>

    <h2><a name="Component Library"></a>Component Library</h2>

    <blockquote>

      <p>A package that creates a component library in the Gaudi sense
	(e.g. Algorithms, Services or Converters) should use one of
	the following standard patterns:</p>

      <pre>
apply_pattern component_interface        [1]
apply_pattern component_implementation   [2]
apply_pattern component_library          [3]
      </pre>

      Notes:

      <ol>

	<li> This applies to a package that just specifies the
	  interface (via header files) to a set of components.</li>

	<li> This applies to a package that just implements a set
	  of components (and will therefore have a "use" relationship
	  with another package that specifies the interface).</li>

	<li> This applies to a package that simultaneously specifies
	  both the interface and implementation of a set of
	  components.</li>

      </ol>

    </blockquote>

    <h2><a name="Linker Library"></a>Linker Library</h2>

    <blockquote>

      <p>A package that creates a library that needs to be linked
	against, typically dynamically at run-time), should use the
	following standard pattern:</p>

      <pre>
apply_pattern installed_library
      </pre>

    </blockquote>
    
    <h2><a name="Application"></a>Application</h2>
    
    <blockquote>

      <p>A package that creates an application should use the following pattern:</p>

      <pre>
application &lt;name&gt; &lt;list of files&gt;
      </pre>

      e.g.

      <pre>
application athena AthenaMain.cxx
      </pre>

      <p>Then it may also define an alias to this application using
	the following pattern:</p>

      <pre>
apply_pattern application_alias application=xyz [1]
      </pre>
      
      <ol>
	
	<li> This defines by default the alias xyz pointing at the
	  xyz.exe application expected in the binary directory of the
	  package.</li>
	
      </ol>
      
    </blockquote>

    </blockquote>
    
    <hr></hr>
    <h1><a name="Not yet compiled comments"></a>Not yet compiled comments</h1>

    <blockquote>



<pre>

   First comments:

   + I think this idea of "systematically" build a temporary container
 package is very good. In principle instead of :

     > cd <dir>
     > mkdir TestRelease
     > mkdir TestRelease/cmt
     > cd TestRelease/cmt
     > cat > requirements

      it might be possible to do :

     > cd <dir>
     > cmt create TestRelease v1
     > cd TestRelease/v1/cmt
     > vi requirements

     I have to understand the kind of persistency is applied to this
 TestRelease. It seems to be volatile but...

     What you have done works although CMT understands the directory
 hierarchy :

     .../<dir>/TestRelease/cmt

     as 'The package <dir> at version "TestRelease" ' which might not 
be
 what you meant ?? However this understanding by CMT has NO impact on
 what we do as long as we don't try to exploit the package name (ie. we
 don't care CMT-generated macros such as <package>_tag, or this test
 release is not "used").

I played around with this and as long as I didn't use "package <name>"
within the requireemnts file it seemed to work. Originally I had in fact
made it a pseudo-package with a fake tag, but it seems very volatile and
obviously shouldn't be checked into CVS. Presumably it could live in CVS
just to give a template.


   + I will check the list of env. variables

   + I'll probably also describe the alternate primary setup scenario
 (while yours is fine, very simple and quite understandable by
 newcomers) which probably offers more flexibility in long term, ie the
 one based on the login requirements file. This scenario anyway 
requires
 at least :

     export CMTBASE=/afs/cern.ch/sw/contrib/CMT
     export CMTVERS=v1r9
     source setup.sh                             [1]


     [1] this needs to be prepared once by a "cmt config" although the
 scenario of re-config'ing when one changes CMT version has to be
 explicited. In you scenario, it's a matter of changing CMTVERS, in 
mine
 it's a matter of running again "cmt config". Well the complete 
sequence

     export CMTBASE=/afs/cern.ch/sw/contrib/CMT
     export CMTVERS=v1r9
     source $CMTBASE/$CMTVERS/mgr/setup.sh
     cmt config

    is a way to combine both scenarios (the "cmt config" command here 
is
 not really heavy and can be re-done continuously without any harm but
 could also be commented out as long as CMTVERS is not changed...)


I was just worried if anyone ever did a "gmake" on this requirements 
file.


**********************************************************


 I guess the right style would be to :

 
=======================================================================
   1) have a core part package for a particular domain which could be
 linked against as a normal library by "internal" packages in the same
 domain

   2) have the interface package as foreseen

   3) have the true implementation component package which would make
 use of the core part.
 
=======================================================================


******************************************************

   o other scenarios
   o CVS scenarios
   o binary tag management
       platform/compiler conventions
       special builds (insure, debug, etc...)
   o external packages
   o transporting the software
   o ...



</pre>

    </blockquote>

</body>
</html>
