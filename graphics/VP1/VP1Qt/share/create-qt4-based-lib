#!/bin/bash

# Script which facilitates the use of qmake within the atlas offline
# framework. See the requirement files of the various VP1 packages for
# examples of how to use it.
#
# Thomas Kittelmann, First version May 2007.

APPNAME=`basename $0`
if [ $? != 0 -o "x$APPNAME" == "x" ]; then
    echo "$0: ERROR - could not determine application name!"
    exit 1
fi

if [ "x"`basename $PWD` != "xcmt" ]; then
    echo "$APPNAME: ERROR - must be invoked from cmt dir (pwd is: $PWD)"
    exit 1
fi

for cmd in cmt basename ln cp rm mkdir make; do
    which "$cmd" > /dev/null 2>&1
    if [ $? != 0 ]; then
	echo "$APPNAME: ERROR - $cmd command not in path!"
	exit 1
    fi
done

COINHOME=`cmt -quiet show macro_value AtlasCoinInventor_home` || COINHOME=""
SOQTHOME=`cmt -quiet show macro_value AtlasSoQt_home` || SOQTHOME=""

MOC_LOADED=0 # stores the info about the loading of the MOC, when we need to set optional MOC flags, below

PACKAGENAME=`cmt show macro_value package`
if [ $? != 0 -o "x$PACKAGENAME" == "x" ]; then
    echo "$APPNAME: ERROR - could not determine PACKAGENAME!"
    exit 1
fi

INSTALLAREA=`cmt show macro_value CMTINSTALLAREA`
if [ $? != 0 -o "x$INSTALLAREA" == "x" ]; then
    echo "$APPNAME: ERROR - Could not determine location of install area from CMTINSTALLAREA macro!"
    exit 1
fi

LIBPOSTFIX="so"
LIBPOSTFIXFULLVERS="so.1.0.0"
if [[ "$CMTCONFIG" =~ "mac" ]]; then
    LIBPOSTFIX="dylib"
    LIBPOSTFIXFULLVERS="1.0.0.dylib"
fi

VP1QMAKEDIR=$INSTALLAREA/$CMTCONFIG/bin/vp1qmake
VP1QMAKE=$VP1QMAKEDIR/qmake
VP1QTCONF=$VP1QMAKEDIR/qt.conf

QTDIR=`cmt show macro_value Qt4_home`
if [ $? != 0 -o "x$QTDIR" == "x" ]; then
    echo "$APPNAME: ERROR - Could not determine location of qt (result: QTDIR=$QTDIR)!"
    exit 1
fi

if [ ! -f "$QTDIR/bin/qmake" ]; then
    echo "$APPNAME: ERROR - Could not find QTDIR/bin/qmake (QTDIR=$QTDIR)"
    exit 1
fi

#Figure out VP1ATLREL define:
if [ "x$AtlasVersion" == "x" ]; then
    VP1ATLREL="999999"
else
    MAJOR=`echo $AtlasVersion|tr '.' ' '|awk '{print $1}'` || MAJOR="99"
    MINOR=`echo $AtlasVersion|tr '.' ' '|awk '{print $2}'` || MINOR="99"
    PATCH=`echo $AtlasVersion|tr '.' ' '|awk '{print $3}'` || PATCH="99"
    #must be numeric:
    echo "$MAJOR" | grep -q -v "[^0-9]" || MAJOR="99"
    echo "$MINOR" | grep -q -v "[^0-9]" || MINOR="99"
    echo "$PATCH" | grep -q -v "[^0-9]" || PATCH="99"

    if [ "x$MAJOR" == "x" -o ${#MAJOR} -gt 2 ]; then
	MAJOR="99"
    fi
    if [ "x$MINOR" == "x" -o ${#MINOR} -gt 2 ]; then
	MINOR="99"
    elif [ ${#MINOR} -eq 1 ]; then
	MINOR="0$MINOR"
    fi
    if [ "x$PATCH" == "x" -o ${#PATCH} -gt 2 ]; then
	PATCH="99"
    elif [ ${#PATCH} -eq 1 ]; then
	PATCH="0$PATCH"
    fi
    VP1ATLREL="${MAJOR}${MINOR}${PATCH}"
fi

cd ../${CMTCONFIG}/ && \
#Create symlink for header files in installarea
echo "$APPNAME: Linking header files in installarea" && \
if [ ! -d $INSTALLAREA/include/ ]; then mkdir $INSTALLAREA/include/; fi && \
if [ ! -d $INSTALLAREA/$CMTCONFIG ]; then mkdir $INSTALLAREA/$CMTCONFIG; fi && \
if [ ! -d $INSTALLAREA/$CMTCONFIG/lib ]; then mkdir $INSTALLAREA/$CMTCONFIG/lib; fi && \
HEADERDIR=`dirname ${PWD}`/${PACKAGENAME} && \
if [ ! -d $INSTALLAREA/include/${PACKAGENAME} ]; then
    ln -sf ${HEADERDIR} $INSTALLAREA/include/ && \
    echo ${HEADERDIR} > $INSTALLAREA/include/${PACKAGENAME}.cmtref
elif [ ! -L $INSTALLAREA/include/${PACKAGENAME} -a ! -d $INSTALLAREA/include/${PACKAGENAME} ]; then
    ln -sf ${HEADERDIR} $INSTALLAREA/include/${PACKAGENAME}/ && \
    echo ${HEADERDIR} > $INSTALLAREA/include/${PACKAGENAME}/${PACKAGENAME}.cmtref
fi && \
#Create pro file:
rm -f temp.pro && touch temp.pro && \
echo "$APPNAME: Creating project file" && \
echo "TEMPLATE = lib" >> temp.pro && \
echo "DESTDIR = ." >> temp.pro && \
echo "TARGET = ${PACKAGENAME}" >> temp.pro && \
#NB: Must avoid version numbers embedded in libs:
echo "QMAKE_LFLAGS_SONAME =" >> temp.pro && \
echo "UI_DIR=tmpqt" >> temp.pro && \
echo "MOC_DIR=tmpqt" >> temp.pro && \
echo "OBJECTS_DIR=tmpqt" >> temp.pro && \
echo "RCC_DIR=tmpqt" >> temp.pro && \
echo "QMAKE_CLEAN += ${CMTCONFIG}_Makefile.qmake" >> temp.pro && \
echo "QMAKE_CLEAN += tmpqt" >> temp.pro && \
### TEST ###
#echo "load(moc)" >> temp.pro && \
#echo "QMAKE_MOC += -DBOOST_TT_HAS_OPERATOR_HPP_INCLUDED" >> temp.pro && \
############
echo "DEFINES += VP1ATLREL=$VP1ATLREL" >> temp.pro && \
SRCFILESCXX=`echo ../src/*.cxx` && if [ "x$SRCFILESCXX" == "x../src/*.cxx" ]; then SRCFILESCXX=""; fi && \
SRCFILESCPP=`echo ../src/*.cpp`&& if [ "x$SRCFILESCPP" == "x../src/*.cpp" ]; then SRCFILESCPP=""; fi && \
HEADERFILES=`echo ../$PACKAGENAME/*.h` && if [ "x$HEADERFILES" == "x../$PACKAGENAME/*.h" ]; then HEADERFILES=""; fi && \
INLINEFILES=`echo ../$PACKAGENAME/*.icc` && if [ "x$INLINEFILES" == "x../$PACKAGENAME/*.icc" ]; then INLINEFILES=""; fi && \
HEADERFILESINSRCDIR=`echo ../src/*.h` && if [ "x$HEADERFILESINSRCDIR" == "x../src/*.h" ]; then HEADERFILESINSRCDIR=""; fi && \
RESOURCEFILES=`echo ../src/*.qrc` && if [ "x$RESOURCEFILES" == "x../src/*.qrc" ]; then RESOURCEFILES=""; fi && \
UIFILES=`echo ../src/*.ui` && if [ "x$UIFILES" == "x../src/*.ui" ]; then UIFILES=""; fi && \
PLUGIN=0 && \
if [ "x$HEADERFILES" != "x" ]; then echo "HEADERS += ${HEADERFILES}" >> temp.pro; fi && \
if [ "x$INLINEFILES" != "x" ]; then echo "HEADERS += ${INLINEFILES}" >> temp.pro; fi && \
if [ "x$SRCFILESCXX" != "x" ]; then echo "SOURCES += ${SRCFILESCXX}" >> temp.pro; fi && \
if [ "x$SRCFILESCPP" != "x" ]; then echo "SOURCES += ${SRCFILESCPP}" >> temp.pro; fi && \
if [ "x$HEADERFILESINSRCDIR" != "x" ]; then echo "HEADERS += ${HEADERFILESINSRCDIR}" >> temp.pro; fi && \
if [ "x$RESOURCEFILES" != "x" ]; then echo "RESOURCES += ${RESOURCEFILES}" >> temp.pro; fi && \
if [ "x$UIFILES" != "x" ]; then echo "FORMS += ${UIFILES}" >> temp.pro; fi && \
if [ -d tmpqt_extraheaders/ ]; then
    EXTRAHEADERFILES=`echo tmpqt_extraheaders/*.h` && if [ "x$EXTRAHEADERFILES" == "xtmpqt_extraheaders/*.h" ]; then EXTRAHEADERFILES=""; fi && \
    if [ "x$EXTRAHEADERFILES" != "x" ]; then echo "HEADERS += ${EXTRAHEADERFILES}" >> temp.pro; fi
fi && \
if [ -d tmpqt_extrasrc/ ]; then
    EXTRASRCFILESCXX=`echo tmpqt_extrasrc/*.cxx` && if [ "x$EXTRASRCFILESCXX" == "xtmpqt_extrasrc/*.cxx" ]; then EXTRASRCFILESCXX=""; fi && \
    EXTRASRCFILESCPP=`echo tmpqt_extrasrc/*.cpp` && if [ "x$EXTRASRCFILESCPP" == "xtmpqt_extrasrc/*.cpp" ]; then EXTRASRCFILESCPP=""; fi && \
    if [ "x$EXTRASRCFILESCXX" != "x" ]; then echo "SOURCES += ${EXTRASRCFILESCXX}" >> temp.pro; fi && \
    if [ "x$EXTRASRCFILESCPP" != "x" ]; then echo "SOURCES += ${EXTRASRCFILESCPP}" >> temp.pro; fi
fi && \
#Fixme: Move the next two to AtlasCoinInventor and AtlasSoQt instead somehow:
if [ "x$COINHOME" != "x" -a -f $COINHOME/bin/coin-config ]; then
    echo 'LIBS += $$system("'"$COINHOME/bin/coin-config"' --libs")' >> temp.pro
fi && \
if [ "x$SOQTHOME" != "x" -a -f $SOQTHOME/bin/soqt-config ]; then
    echo 'LIBS += $$system("'"$SOQTHOME/bin/soqt-config"' --libs")' >> temp.pro
fi && \
for arg in $*; do
    if [ "x${arg}" == "xnogui" ]; then
	    echo "QT -= gui" >> temp.pro
    elif [ "x${arg}" == "xqtplugin" ]; then
	    echo "QT += plugin" >> temp.pro && PLUGIN=1
    elif [ "x${arg:0:11}" == "xinstsubdir:" ]; then
	    INSTSUBDIR=${arg:11:$((${#arg}-11))}
    elif [ "x${arg:0:8}" == "xneedlib:" ]; then
	    echo 'LIBS += -l'"${arg:8:$((${#arg}-8))}" >> temp.pro
    elif [ "x${arg:0:5}" == "xneed:" ]; then
	    echo "QT += "${arg:5:$((${#arg}-5))} >> temp.pro
    elif [ "x${arg:0:9}" == "xmocflags:" ]; then
        if [ $MOC_LOADED -eq 0 ]; then 
            # even if the user specify N MOC options, "load(moc)" is printed only once
            echo "# additional user options for MOC" >> temp.pro
            echo "load(moc)" >> temp.pro
            MOC_LOADED=1
        fi
	    echo "QMAKE_MOC += "${arg:9:$((${#arg}-9))} >> temp.pro
    else
	echo "$APPNAME: WARNING - Unknown argument: $arg"
    fi
done && \
#add includes:
if [ "x$HEADERFILESINSRCDIR" != "x" ]; then
    echo "INCLUDEPATH += ../src" >> temp.pro
    echo "DEPENDPATH += ../src" >> temp.pro
fi && \
#We do it in two rounds to make sure that stuff from the current install area gets precedence!
for incdir in `cmt show macro_value includes|tr ' ' '\n'|grep -v '^ *$'|uniq |sed 's#^ *-I"##'|sed 's#" *$##'`; do
    if [ -d $incdir ]; then
	if [ ${#INSTALLAREA} -le ${#incdir} -a "x${incdir:0:${#INSTALLAREA}}" == "x${INSTALLAREA}" ]; then
	    echo "INCLUDEPATH += ${incdir}" >> temp.pro
	    echo "DEPENDPATH += ${incdir}" >> temp.pro
	fi
    fi
done && \
for incdir in `cmt show macro_value includes|tr ' ' '\n'|grep -v '^ *$'|uniq |sed 's#^ *-I"##'|sed 's#" *$##'`; do
    if [ -d $incdir ]; then
	if [ ${#INSTALLAREA} -gt ${#incdir} -o "x${incdir:0:${#INSTALLAREA}}" != "x${INSTALLAREA}" ]; then
	    TEST=`echo ${incdir}|grep -i vp1patch`|| TEST=""
	    if [ "x$TEST" != "x" ]; then
  	        #For the vp1 binary patches to work, we must add a few extra statements to that one.
		for package in `cmt show uses|grep '^use '|awk '{print $2}'`; do
		    EXTRAINCDIR=${incdir}/${package}
		    if [ -d "${incdir}/$package" ]; then
			echo "INCLUDEPATH += ${incdir}/${package}" >> temp.pro
			echo "DEPENDPATH += ${incdir}/${package}" >> temp.pro
		    fi
		done
	    fi
	    echo "INCLUDEPATH += ${incdir}" >> temp.pro
	    echo "DEPENDPATH += ${incdir}" >> temp.pro
	fi
    fi
done && \
#Add atlas cpp flags:
for cmtmacrowithcxxflags in cppflags AtlasCxxPolicy_pp_cppflags; do
    echo "QMAKE_CXXFLAGS += "`cmt show macro_value $cmtmacrowithcxxflags` >> temp.pro
done && \
#Add atlas link flags:
for cmtmacrowithlinkflags in cpplinkflags use_linkopts; do
    #We make sure that we NEVER add -l<packagename> (with the present package name) to the link options.
   LINKLINE=""
   for entry in `cmt show macro_value $cmtmacrowithlinkflags`; do
       if [ "x${entry}" != "x-l${PACKAGENAME}" ]; then
	   if [ "x$GCC_SITE" != "x" ]; then
	       #This section should just be about .so's, since we dont expect GCC_SITE on a mac (for now)
	       #Fixme: don't hardcode .so.1
	       ISFORTRAN=0
	       echo "$entry"|grep libgfortran.so.1 > /dev/null && ISFORTRAN=1
	       echo "$entry"|grep libgfortran.so.2 > /dev/null && ISFORTRAN=2
	       echo "$entry"|grep libgfortran.so.3 > /dev/null && ISFORTRAN=3
	       echo "$entry"|grep libgfortran.so.4 > /dev/null && ISFORTRAN=4
	       echo "$entry"|grep libgfortran.so.5 > /dev/null && ISFORTRAN=5
	       if [ "$ISFORTRAN" != "0" ]; then
		   entry="$GCC_SITE/lib/libgfortran.so.${ISFORTRAN}"
	       fi
	   fi
	   LINKLINE="${LINKLINE} ${entry}"
       fi
   done && \
   if [ "x${LINKLINE}" != "x" ]; then
       echo "QMAKE_LFLAGS += ${LINKLINE}" >> temp.pro
   fi
done && \
COMPILEASDEBUG=0 && \
if [ "x$PLUGIN" != "x1" ]; then
    #NB: Plugins will never be compiled in debug mode! (otherwise we need debug qt dirs to load them)
    if [ "x${CMTCONFIG:${#CMTCONFIG}-4:4}" == "x-dbg" -o "x$VP1FORCEDEBUG" == "x1" ]; then
	COMPILEASDEBUG=1
    fi
    if [  "x$COMPILEASDEBUG" == "x1" ]; then
	if [[ "$CMTCONFIG" =~ "mac" ]]; then
	    echo "NB: Will never compile Qt packages with debug information in Mac builds"
	    COMPILEASDEBUG=0
	fi
    fi
fi && \
    if [ "x$COMPILEASDEBUG" == "x1" ]; then
    echo "CONFIG -= release" >> temp.pro
    echo "CONFIG += debug" >> temp.pro
else
    echo "QMAKE_CXXFLAGS -= -g" >> temp.pro
    echo "CONFIG -= debug" >> temp.pro
    echo "CONFIG += release" >> temp.pro
fi && \
#When compiling 32bit lib on 64bit machine, some of the libs are not properly symlinked. The following hack works around this:
MACHINETYPE=`uname -m` && \
BUILDTYPE=`echo $CMTCONFIG|sed 's#-.*$##'` && \
if [ "x$MACHINETYPE" != "x$BUILDTYPE" -a "x$BUILDTYPE" != "xx86_64" ]; then
    mkdir -p tmpqt_extraincludes && \
    echo 'LIBS += -L'"$PWD"'/tmpqt_extraincludes' >> temp.pro && \
    for dependency in png fontconfig glib-2.0 gthread-2.0; do
	EXTRALIB=`ldd -r $QTDIR/lib/libQtGui.so|grep "lib${dependency}"'.*so'|tr ' ' '\n'|grep '^/'|head -1` && \
        if [ ! -f $EXTRALIB ]; then return 1; fi && \
	ln -sf $EXTRALIB tmpqt_extraincludes/lib${dependency}.so
    done
fi && \
PATH=$QTDIR/bin:$PATH && \
LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATH && \
#get a local qmake and qt.conf which is needed because of stupid hardcoded absolute paths:
if [ -f ${VP1QMAKE}.lock ]; then
    i=0
    while [ -f ${VP1QMAKE}.lock ]; do
	i=$((i+1))
	if [ $i == 600 ]; then
	    echo "$APPNAME: Stop waiting for other package copying qmake. Aborting."
	    exit 1
	fi
	sleep 1
    done
fi && \
if [ ! -f $VP1QMAKE ]; then
    #Let us try to make sure we dont have race-conditions with packages build in parallel:
    echo "$APPNAME: Copying qmake to install area"
    mkdir -p $VP1QMAKEDIR
    if [ -f ${VP1QMAKE}.lock ]; then
	echo "$APPNAME: Possible race condition detected. Waiting while other package copies qmake to install area"
	i=0
	while [ -f ${VP1QMAKE}.lock ]; do
	    i=$((i+1))
	    if [ $i == 600 ]; then
		echo "$APPNAME: Dang, this is going nowhere. Aborting."
		exit 1
	    fi
	    sleep 1
	done
	#a few more seconds so qt.conf also can get created with no race condition:
	sleep 20
    else
	touch ${VP1QMAKE}.lock
	cp $QTDIR/bin/qmake $VP1QMAKE
	rm -f ${VP1QMAKE}.lock
    fi
fi && \
if [ ! -f $VP1QTCONF ]; then
    echo "$APPNAME: Creating qt.conf"
    mkdir -p $VP1QMAKEDIR
    echo '[Paths]' > $VP1QTCONF
    echo "Prefix=$QTDIR" >> $VP1QTCONF
fi && \
#Run qmake:
echo "$APPNAME: Generate makefile" && \
mkdir -p tmpqt && \
rm -f ${CMTCONFIG}_Makefile.qmake && \
$VP1QMAKE temp.pro -o ${CMTCONFIG}_Makefile.qmake && \
#Make:
echo "$APPNAME: Actual make step" && \
make -j1 -f ${CMTCONFIG}_Makefile.qmake && \
#For the kit: Make sure that libPackageName.${LIBPOSTFIX} is a real file and not
#just a symlink (Qt produces libPackageName.${LIBPOSTFIXFULLVERS} as the real file):
#TESTif [ -h lib${PACKAGENAME}.${LIBPOSTFIX} -a -f lib${PACKAGENAME}.${LIBPOSTFIXFULLVERS} ]; then
if [ -f lib${PACKAGENAME}.${LIBPOSTFIX} -a -f lib${PACKAGENAME}.${LIBPOSTFIXFULLVERS} ]; then
    rm -f lib${PACKAGENAME}.${LIBPOSTFIX} && \
	mv -f lib${PACKAGENAME}.${LIBPOSTFIXFULLVERS} lib${PACKAGENAME}.${LIBPOSTFIX} && \
	rm -f lib${PACKAGENAME}.*.${LIBPOSTFIX} lib${PACKAGENAME}.${LIBPOSTFIX}.*
fi && \
#Create symlink for library file in installarea
echo "$APPNAME: Linking library in installarea" && \
if [ ! -d $INSTALLAREA/${CMTCONFIG}/ ]; then mkdir $INSTALLAREA/${CMTCONFIG}/; fi && \
if [ ! -d $INSTALLAREA/${CMTCONFIG}/lib ]; then mkdir $INSTALLAREA/${CMTCONFIG}/lib; fi && \
if [ "$INSTSUBDIR" == "x" ]; then
    ln -sf ${PWD}/lib${PACKAGENAME}.${LIBPOSTFIX} $INSTALLAREA/${CMTCONFIG}/lib/ && \
    echo ${PWD}/lib${PACKAGENAME}.${LIBPOSTFIX} > $INSTALLAREA/${CMTCONFIG}/lib/lib${PACKAGENAME}.cmtref
else
    if [ ! -d $INSTALLAREA/${CMTCONFIG}/lib/$INSTSUBDIR ]; then
	mkdir $INSTALLAREA/${CMTCONFIG}/lib/$INSTSUBDIR
    fi
    ln -sf ${PWD}/lib${PACKAGENAME}.${LIBPOSTFIX} $INSTALLAREA/${CMTCONFIG}/lib/$INSTSUBDIR/ && \
    echo ${PWD}/lib${PACKAGENAME}.${LIBPOSTFIX} > $INSTALLAREA/${CMTCONFIG}/lib/$INSTSUBDIR/lib${PACKAGENAME}.cmtref && \
    ln -sf ${PWD}/lib${PACKAGENAME}.${LIBPOSTFIX} $INSTALLAREA/${CMTCONFIG}/lib/$INSTSUBDIR/lib${PACKAGENAME}.${LIBPOSTFIXFULLVERS}
fi && \
cd ../cmt/
