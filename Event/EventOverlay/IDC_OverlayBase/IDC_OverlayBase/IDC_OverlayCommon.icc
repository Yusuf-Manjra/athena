/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// Generic overlaying code for Identifiable Containers.
//
// Andrei Gaponenko <agaponenko@lbl.gov>, 2006-2009

#include "Identifier/Identifier.h"
#include "Identifier/IdentifierHash.h"

#include "AthenaBaseComps/AthMsgStreamMacros.h"

#include "DataModel/DataVector.h"

#include <sstream>

namespace Overlay {
  
  template<class IDC_Container> 
  std::string shortPrint(const IDC_Container *container, unsigned maxprint) {
    std::ostringstream os;
    if(container) {
      for(unsigned i=0; i<maxprint; i++) {
	typename IDC_Container::const_iterator p = container->indexFind(i);
	if(p != container->end()) {
	  os<<" "<< (*p)->size();
	}
	else {
	  os<<" *";
	}
      }
    }
    else {
      os<<"(NULL)";
    }
    return os.str();
  }


  //================================================================
  template<class IDC_Container, class OvlAlg>
  void overlayContainerNew(IDC_Container *dataContainer,
			IDC_Container *mcContainer,
			OvlAlg *parent)
  {
    typedef typename IDC_Container::base_value_type Collection;

    if(parent->msgLvl(MSG::DEBUG)) { parent->msg(MSG::DEBUG)<<"overlayContainerNew<>() begin"<<endreq; }
    
    // The  MC signal container should typically be smaller than
    // dataContainer, because the latter contains all the noise,
    // min bias and pile up.   Thus we loop other MC inputs.

    // We are modifying both mcContainer and dataContainer in the loop.
    // That invalidates iterators.  Therefore we prepare a list of
    // hashIds to work with and keep it in a separate container that is 
    // not modified during the loop.

    std::vector<IdentifierHash> mc_hashIds;
    mc_hashIds.reserve(mcContainer->numberOfCollections());
    for(typename IDC_Container::const_iterator p = mcContainer->begin(); 
	p != mcContainer->end();
	++p)
      {
	mc_hashIds.push_back( p.hashId() );
      }

    for(std::vector<IdentifierHash>::const_iterator ph = mc_hashIds.begin(); 
	ph != mc_hashIds.end();
	++ph)
      {
      
	IdentifierHash hashId = *ph;

	// Take possession of the MC store collection
	// If there is no matching collection in dataContainer we just transfer
	// this whole collection to the "data" container.
	Collection *c_mc = mcContainer->removeCollection(hashId);
      
	// Look for the same ID in the dataContainer SG

	// FIXME: removeCollection() should not need this protection.
	// But without it, just using
	// 
	//       Collection *c_data = dataContainer->removeCollection(hashId);
	//
	// we get
	//
	//  InDetOverlay                                   DEBUG TRT MC   =  * 2 1 1 1 1 * 1 * * * * * 1 * * * 1 1 * 2 1 * 1 1
	//  InDetOverlay                                   DEBUG overlayContainerNew<>() begin
	//  IDC_OverlayBase::overlayContainerNew() line= 163
	//  IDC_OverlayBase::overlayContainerNew() line= 169
	//  InDetOverlay.sysExecute()                      FATAL  Standard std::exception is caught
	//  InDetOverlay.sysExecute()                      ERROR dereferencing invalid DataLink
	//
	// So use the following for now:
      
	Collection *c_data =
	  (dataContainer->indexFind(hashId) != dataContainer->end()) ? dataContainer->removeCollection(hashId) : 0;

	if(c_data) {
	  // Need to merge the collections
	  if(parent->msgLvl(MSG::VERBOSE)) { parent->msg(MSG::VERBOSE)<<"Merging collections"<<endreq; }

          //parent->mergeCollections(c_mc, c_data);
	  mergeCollectionsNew(c_mc, c_data, parent);
	}
	else {
	  if(parent->msgLvl(MSG::VERBOSE)) {
	    parent->msg(MSG::VERBOSE)<<"Transferring to dataContainer complete ovl collection, no merging"<<endreq;
	  }
	}

	if(dataContainer->addCollection(c_mc, hashId).isFailure()) {
	  if(parent->msgLvl(MSG::WARNING)) {
	    parent->msg(MSG::WARNING)<<"overlayContainerNew(): Problem in dataContainer->addCollection(hash) for ovl collection="
				     <<c_mc<<endreq;
	  }
	}

      }
  }


  //================================================================
  template<class IDC_Container, class OvlAlg>
  void overlayContainer(IDC_Container *dataContainer,
			IDC_Container *mcContainer,
			OvlAlg *parent)
  {
    typedef typename IDC_Container::base_value_type Collection;

    if(parent->msgLvl(MSG::DEBUG)) { parent->msg(MSG::DEBUG)<<"overlayContainer<>() begin"<<endreq; }
    
    // The  MC signal container should typically be smaller than
    // dataContainer, because the latter contains all the noise,
    // min bias and pile up.   Thus we loop other MC inputs.

    // We are modifying both mcContainer and dataContainer in the loop.
    // That invalidates iterators.  Therefore we prepare a list of
    // hashIds to work with and keep it in a separate container that is 
    // not modified during the loop.

    std::vector<IdentifierHash> mc_hashIds;
    mc_hashIds.reserve(mcContainer->numberOfCollections());
    for(typename IDC_Container::const_iterator p = mcContainer->begin(); 
	p != mcContainer->end();
	++p)
      {
	mc_hashIds.push_back( p.hashId() );
      }

    for(std::vector<IdentifierHash>::const_iterator ph = mc_hashIds.begin(); 
	ph != mc_hashIds.end();
	++ph)
      {
      
	IdentifierHash hashId = *ph;

	// Take possession of the MC store collection
	// If there is no matching collection in dataContainer we just transfer
	// this whole collection to the "data" container.
	Collection *c_mc = mcContainer->removeCollection(hashId);
      
	// Look for the same ID in the dataContainer SG

	// FIXME: removeCollection() should not need this protection.
	// But without it, just using
	// 
	//       Collection *c_data = dataContainer->removeCollection(hashId);
	//
	// we get
	//
	//  InDetOverlay                                   DEBUG TRT MC   =  * 2 1 1 1 1 * 1 * * * * * 1 * * * 1 1 * 2 1 * 1 1
	//  InDetOverlay                                   DEBUG overlayContainer<>() begin
	//  IDC_OverlayBase::overlayContainer() line= 163
	//  IDC_OverlayBase::overlayContainer() line= 169
	//  InDetOverlay.sysExecute()                      FATAL  Standard std::exception is caught
	//  InDetOverlay.sysExecute()                      ERROR dereferencing invalid DataLink
	//
	// So use the following for now:
      
	Collection *c_data =
	  (dataContainer->indexFind(hashId) != dataContainer->end()) ? dataContainer->removeCollection(hashId) : 0;

	if(c_data) {
	  // Need to merge the collections
	  if(parent->msgLvl(MSG::VERBOSE)) { parent->msg(MSG::VERBOSE)<<"Merging collections"<<endreq; }

          parent->mergeCollections(c_mc, c_data);
	}
	else {
	  if(parent->msgLvl(MSG::VERBOSE)) {
	    parent->msg(MSG::VERBOSE)<<"Transferring to dataContainer complete ovl collection, no merging"<<endreq;
	  }
	}

	if(dataContainer->addCollection(c_mc, hashId).isFailure()) {
	  if(parent->msgLvl(MSG::WARNING)) {
	    parent->msg(MSG::WARNING)<<"overlayContainer(): Problem in dataContainer->addCollection(hash) for ovl collection="
				     <<c_mc<<endreq;
	  }
	}

      }
  }

} // namespace Overlay

//================================================================
