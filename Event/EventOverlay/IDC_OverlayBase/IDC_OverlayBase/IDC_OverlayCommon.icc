/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// Generic overlaying code for Identifiable Containers.
//
// Andrei Gaponenko <agaponenko@lbl.gov>, 2006-2009

#include "Identifier/Identifier.h"
#include "Identifier/IdentifierHash.h"

#include "AthenaBaseComps/AthMsgStreamMacros.h"

#include "DataModel/DataVector.h"

#include <sstream>

namespace Overlay {
  
  template<class IDC_Container> 
  std::string shortPrint(const IDC_Container *container, unsigned maxprint) {
    std::ostringstream os;
    if(container) {
      for(unsigned i=0; i<maxprint; i++) {
	typename IDC_Container::const_iterator p = container->indexFind(i);
	if(p != container->end()) {
	  os<<" "<< (*p)->size();
	}
	else {
	  os<<" *";
	}
      }
    }
    else {
      os<<"(NULL)";
    }
    return os.str();
  }


  //================================================================
  template<class IDC_Container, class OvlAlg>
  void overlayContainerNew(const IDC_Container *dataContainer,
			const IDC_Container *mcContainer,
                        IDC_Container *outputContainer,       
			OvlAlg *parent)
  {
    typedef typename IDC_Container::base_value_type Collection;

    if(parent->msgLvl(MSG::DEBUG)) { parent->msg(MSG::DEBUG)<<"overlayContainerNew<>() begin"<<endmsg; }

   /** Add data from the data container to the output one */
   typename IDC_Container::const_iterator p_data = dataContainer->begin();
   typename IDC_Container::const_iterator p_data_end = dataContainer->end();

   for(; p_data != p_data_end; ++p_data) {
   IdentifierHash hashId = p_data.hashId();
   Collection *coll_data=new Collection(hashId); 
   copyCollection(p_data->cptr(),coll_data);
   
   if ( outputContainer->addCollection(coll_data, p_data.hashId()).isFailure() ) {
      parent->msg(MSG::WARNING) <<"add data Collection failed for output "<< p_data.hashId()<<endmsg; //" collectionNo "<<collectionNo<<endmsg; 
      }
   }     

  /** Add data from the ovl container to the output one */
  typename IDC_Container::const_iterator p_ovl = mcContainer->begin(); 
  typename IDC_Container::const_iterator p_ovl_end = mcContainer->end();

  for(; p_ovl != p_ovl_end; ++p_ovl) {
 
  IdentifierHash coll_id = p_ovl.hashId();//(*p_ovl)->identify();
  Collection *coll_ovl=new Collection(coll_id); 
  copyCollection(p_ovl->cptr(),coll_ovl);

   /** The newly created stuff will go to the output EventStore SG */
   Collection *out_coll = new Collection( coll_id );
   out_coll->setIdentifier((*p_ovl)->identify());

/** Look for the same ID in the main StoreGate EventStore */ 
    typename IDC_Container::const_iterator q = outputContainer->indexFind( coll_id );
    if( q != outputContainer->end() ) {
      /** Need to merge the collections
          Retrieve q */

      Collection *coll_data = (Collection *) q->cptr();
      mergeCollectionsNew(coll_data,coll_ovl, out_coll,parent);

      outputContainer->removeCollection(p_ovl.hashId());
      if (outputContainer->addCollection(out_coll, p_ovl.hashId()).isFailure() ) {
	parent->msg(MSG::WARNING) << "overlay addCollection failed " << endreq; 
      }

      }
    else {
      /** Copy the complete collection from ovl to output, 
          hopefully preserving the "most derived" type of its raw data */ 
       if ( outputContainer->addCollection(coll_ovl, coll_id).isFailure() ) {
        	parent->msg(MSG::WARNING) << "add mc Collection failed " << endreq; 
      }
  
  }
   }

  }


  //================================================================
  template<class IDC_Container, class OvlAlg>
  void overlayContainer(IDC_Container *dataContainer,
			IDC_Container *mcContainer,
			OvlAlg *parent)
  {
    typedef typename IDC_Container::base_value_type Collection;

    if(parent->msgLvl(MSG::DEBUG)) { parent->msg(MSG::DEBUG)<<"overlayContainer<>() begin"<<endmsg; }
    
    // The  MC signal container should typically be smaller than
    // dataContainer, because the latter contains all the noise,
    // min bias and pile up.   Thus we loop other MC inputs.

    // We are modifying both mcContainer and dataContainer in the loop.
    // That invalidates iterators.  Therefore we prepare a list of
    // hashIds to work with and keep it in a separate container that is 
    // not modified during the loop.

    std::vector<IdentifierHash> mc_hashIds;
    mc_hashIds.reserve(mcContainer->numberOfCollections());
    for(typename IDC_Container::const_iterator p = mcContainer->begin(); 
	p != mcContainer->end();
	++p)
      {
	mc_hashIds.push_back( p.hashId() );
      }

    for(std::vector<IdentifierHash>::const_iterator ph = mc_hashIds.begin(); 
	ph != mc_hashIds.end();
	++ph)
      {
      
	IdentifierHash hashId = *ph;

	// Take possession of the MC store collection
	// If there is no matching collection in dataContainer we just transfer
	// this whole collection to the "data" container.
	Collection *c_mc = mcContainer->removeCollection(hashId);
      
	// Look for the same ID in the dataContainer SG

	// FIXME: removeCollection() should not need this protection.
	// But without it, just using
	// 
	//       Collection *c_data = dataContainer->removeCollection(hashId);
	//
	// we get
	//
	//  InDetOverlay                                   DEBUG TRT MC   =  * 2 1 1 1 1 * 1 * * * * * 1 * * * 1 1 * 2 1 * 1 1
	//  InDetOverlay                                   DEBUG overlayContainer<>() begin
	//  IDC_OverlayBase::overlayContainer() line= 163
	//  IDC_OverlayBase::overlayContainer() line= 169
	//  InDetOverlay.sysExecute()                      FATAL  Standard std::exception is caught
	//  InDetOverlay.sysExecute()                      ERROR dereferencing invalid DataLink
	//
	// So use the following for now:
      
	Collection *c_data =
	  (dataContainer->indexFind(hashId) != dataContainer->end()) ? dataContainer->removeCollection(hashId) : 0;

	if(c_data) {
	  // Need to merge the collections
	  if(parent->msgLvl(MSG::VERBOSE)) { parent->msg(MSG::VERBOSE)<<"Merging collections"<<endmsg; }

          parent->mergeCollections(c_mc, c_data);
	}
	else {
	  if(parent->msgLvl(MSG::VERBOSE)) {
	    parent->msg(MSG::VERBOSE)<<"Transferring to dataContainer complete ovl collection, no merging"<<endmsg;
	  }
	}

	if(dataContainer->addCollection(c_mc, hashId).isFailure()) {
	  if(parent->msgLvl(MSG::WARNING)) {
	    parent->msg(MSG::WARNING)<<"overlayContainer(): Problem in dataContainer->addCollection(hash) for ovl collection="
				     <<c_mc<<endmsg;
	  }
	}

      }
  }

} // namespace Overlay

//================================================================
