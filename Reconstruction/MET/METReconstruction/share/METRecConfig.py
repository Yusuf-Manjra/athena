from AthenaCommon import Loggingfrom AthenaConfiguration.ComponentAccumulator import ComponentAccumulatorif __name__=="__main__":    # Setting needed for the ComponentAccumulator to do its thing    from AthenaCommon.Configurable import Configurable    Configurable.configurableRun3Behavior=True        # Set message levels    from AthenaCommon import Constants    msgLvl = "WARNING"    from AthenaCommon.Logging import log    log.setLevel(msgLvl)        # Config flags steer the job at various levels    from AthenaConfiguration.AllConfigFlags import ConfigFlags    ConfigFlags.Input.isMC  = True    ConfigFlags.Input.Files = ["/cvmfs/atlas-nightlies.cern.ch/repo/data/data-art/ASG/mc16_13TeV.410501.PowhegPythia8EvtGen_A14_ttbar_hdamp258p75_nonallhad.merge.AOD.e5458_s3126_r9364_r9315/AOD.11182705._000001.pool.root.1"]    # Flags relating to multithreaded execution    nthreads=0    ConfigFlags.Concurrency.NumThreads =nthreads    if nthreads>0:    	ConfigFlags.Concurrency.NumThreads = 1    	ConfigFlags.Concurrency.NumConcurrentEvents = 1    ConfigFlags.MET.UseTracks = True    ConfigFlags.MET.DoPFlow = True    if ConfigFlags.Beam.Type == 'cosmics' or ConfigFlags.Beam.Type == 'singlebeam':# used to have " or not rec.doInDet()" on the end        ConfigFlags.MET.UseTracks = False        ConfigFlags.MET.DoPFlow = False        print "METReconstruction_jobOptions: detected cosmics/single-beam configuration -- switch off track-based MET reco"     ConfigFlags.lock()    # Get a ComponentAccumulator setting up the fundamental Athena job    from AthenaConfiguration.MainServicesConfig import MainServicesThreadedCfg     cfg=MainServicesThreadedCfg(ConfigFlags)     # Add the components for reading in pool files    from AthenaPoolCnvSvc.PoolReadConfig import PoolReadCfg    cfg.merge(PoolReadCfg(ConfigFlags))    from StoreGate.StoreGateConf import StoreGateSvc    cfg.addService(StoreGateSvc("DetectorStore"))    #Setup up general geometry    modelConfig=ComponentAccumulator()    from AtlasGeoModel.GeoModelConfig import GeoModelCfg    modelConfig=GeoModelCfg(ConfigFlags)    cfg.merge(modelConfig)    from MagFieldServices.MagFieldServicesConfig import MagneticFieldSvcCfg    cfg.merge(MagneticFieldSvcCfg(ConfigFlags))    from TrkConfig.AtlasTrackingGeometrySvcConfig import TrackingGeometrySvcCfg    cfg.merge(TrackingGeometrySvcCfg(ConfigFlags))    from MuonConfig.MuonGeometryConfig import MuonGeoModelCfg    cfg.merge(MuonGeoModelCfg(ConfigFlags))          # Get Jet Inputs    from JetRecConfig.StandardJetDefs import EMTopoOrigin, LCTopoOrigin, CHSPFlow    from JetRecConfig import JetRecConfig    cfg1 = JetRecConfig.JetInputCfg( [EMTopoOrigin], ConfigFlags)    cfg.merge( cfg1 )    cfg2 = JetRecConfig.JetInputCfg( [LCTopoOrigin], ConfigFlags)    cfg.merge( cfg2 )    cfg3 = JetRecConfig.JetInputCfg( [CHSPFlow], ConfigFlags)    cfg.merge( cfg3 )    # Need to rename the collections in the xAOD in order to avoid conflicts    from SGComps.AddressRemappingConfig import InputRenameCfg    remap_track=InputRenameCfg('xAOD::MissingETContainer','MET_Track','MET_Track_Old')    remap_trackaux=InputRenameCfg('xAOD::MissingETAuxContainer','MET_TrackAux.','MET_Track_OldAux.')    cfg.merge(remap_track)    cfg.merge(remap_trackaux)        remap_emt=InputRenameCfg('xAOD::MissingETContainer','MET_EMTopo','MET_EMTopo_Old')    remap_emtaux=InputRenameCfg('xAOD::MissingETAuxContainer','MET_EMTopoAux.','MET_EMTopo_OldAux.')    cfg.merge(remap_emt)    cfg.merge(remap_emtaux)        remap_lht=InputRenameCfg('xAOD::MissingETContainer','MET_LocHadTopo','MET_LocHadTopo_Old')    remap_lhtaux=InputRenameCfg('xAOD::MissingETAuxContainer','MET_LocHadTopoAux.','MET_LocHadTopo_OldAux.')    cfg.merge(remap_lht)    cfg.merge(remap_lhtaux)            from METReconstruction.METCfg_Track import METTrack_Cfg    cfg4=METTrack_Cfg(ConfigFlags)    cfg.merge(cfg4)    from METReconstruction.METCfg_Calo import METCalo_Cfg    cfg5=METCalo_Cfg(ConfigFlags)    cfg.merge(cfg5)        # Need to understand how to access the doTruth flag in the current reconstruction SW.    doTruth=True    if doTruth:    	from METReconstruction.METCfg_Truth import METTruth_Cfg    	cfg.merge(METTruth_Cfg(ConfigFlags))    from METReconstruction.METCfg_Associator import METAssociator_Cfg    cfg6=METAssociator_Cfg(ConfigFlags)    cfg.merge(cfg6)                # Start by just trying to add in MET Reconstruction based on METReconstruction_jobOptions.py    #from METReconstruction.METRecoFlags import metFlags    # from AthenaCommon.BeamFlags import jobproperties NO LONGER ALLOWED    # from RecExConfig.RecFlags import rec NO LONGER ALLOWED    #NEED TO CHANGE THIS TO DEPEND ON ConfigFlags.Beam.Type => for now ignore    # TJ: Best to start each of these from scratch as a new CA module,   # Can e.g. make files called METCaloConfig.py that just put the   # old alg into a CA.      # Rather than have N reco tools that get thrown into one alg later,   # have each CA generate its own METRecoAlg and add this to the sequence.      # Probably want to define one CA each for EMTopo, LCTopo and PFlow,   # then have a higher level one that merges in all three,   # then the top-level (i.e. this) can just pull in the all-associators CA    outputlist = ["EventInfo#*"]    outputlist+=["xAOD::MissingETContainer#"+"MET_Track","xAOD::MissingETAuxContainer#"+"MET_Track"+"Aux."]    outputlist+=["xAOD::MissingETContainer#"+"MET_Track_Old","xAOD::MissingETAuxContainer#"+"MET_Track_Old"+"Aux."]    outputlist+=["xAOD::MissingETContainer#"+"MET_EMTopo","xAOD::MissingETAuxContainer#"+"MET_EMTopo"+"Aux."]    outputlist+=["xAOD::MissingETContainer#"+"MET_EMTopo_Old","xAOD::MissingETAuxContainer#"+"MET_EMTopo_Old"+"Aux."]    outputlist+=["xAOD::MissingETContainer#"+"MET_AntiKt4EMPFlow","xAOD::MissingETAuxContainer#"+"MET_AntiKt4EMPFlow"+"Aux."]    from OutputStreamAthenaPool.OutputStreamConfig import OutputStreamCfg    cfg.merge(OutputStreamCfg(ConfigFlags,"xAOD",ItemList=outputlist))        # Optionally, print the contents of the store every event    cfg.getService("StoreGateSvc").Dump = False    #print "Running final component accumulator"    #cfg.printConfig()    cfg.run(maxEvents=20)