/*
  Copyright (C) 2002-2020 CERN for the benefit of the ATLAS collaboration
*/
/**
 * @file CxxUtils/ConcurrentRangeMap.icc
 * @author scott snyder <snyder@bnl.gov>
 * @date Nov, 2017
 * @brief Map from range to payload object, allowing concurrent, lockless reads.
 */


namespace CxxUtils {


#define T_CONCURRENTRANGEMAP template <class RANGE, class KEY, class T, class COMPARE, template <class> class UPDATER>
#define CONCURRENTRANGEMAP ConcurrentRangeMap<RANGE, KEY, T, COMPARE, UPDATER>


/**
 * @brief Constructor.
 * @param delfcn Deletion function.
 * @param capacity Size of the data vector to allocate.
 */
T_CONCURRENTRANGEMAP
CONCURRENTRANGEMAP::Impl::Impl (delete_function* delfcn,
                                size_t capacity /*= 10*/)
  : m_delete (delfcn),
    m_data (capacity)
{
}


/**
 * @brief Destructor.
 *
 * This also deletes payload objects that were passed to discard().
 */
T_CONCURRENTRANGEMAP
CONCURRENTRANGEMAP::Impl::~Impl()
{
  for (const T* p : m_garbage) {
    m_delete (p);
  }
}


/**
 * @brief Return a pointer to the start of the data vector.
 */
T_CONCURRENTRANGEMAP
typename CONCURRENTRANGEMAP::value_type*
CONCURRENTRANGEMAP::Impl::data()
{
  return m_data.data();
}


/**
 * @brief Return the size of the current data vector.
 */
T_CONCURRENTRANGEMAP
size_t
CONCURRENTRANGEMAP::Impl::capacity() const
{
  return m_data.capacity();
}


/***
 * @brief Queue a payload object for deletion.
 */
T_CONCURRENTRANGEMAP
void
CONCURRENTRANGEMAP::Impl::discard (const T* p)
{
  m_garbage.push_back (p);
}


/**
 * @brief Constructor.
 * @param updater Object used to manage memory
 *                (see comments at the start of the class).
 * @param delfcn Deletion function.
 * @param capacity Initial capacity of the map.
 * @param compare Comparison object.
 */
T_CONCURRENTRANGEMAP
CONCURRENTRANGEMAP::ConcurrentRangeMap (Updater_t&& updater,
                                        delete_function* delfcn,
                                        size_t capacity /*= 16*/,
                                        const COMPARE& compare /*= COMPARE()*/)

  : m_updater (std::move (updater)),
    m_compare (compare),
    m_delete (delfcn),
    m_nInserts (0),
    m_maxSize (0)
{
  auto impl = std::make_unique<Impl> (m_delete, capacity);
  value_type* data = impl->data();
  installImpl (std::move (impl),
               data, data,
               Updater_t::defaultContext());
}


/**
 * @brief Destructor.
 *
 * Clean up any remaining payload objects.
 */
T_CONCURRENTRANGEMAP
CONCURRENTRANGEMAP::~ConcurrentRangeMap()
{
  value_type* last = m_last;
  if (last) {
    for (value_type* p = m_begin; p <= m_last; ++p) {
      m_delete (p->second);
    }
      
  }
}


/**
 * @brief Search for the first item less than or equal to KEY.
 * @param key The key to search for.
 * @returns The value, or nullptr if not found.
 */
T_CONCURRENTRANGEMAP
inline
typename CONCURRENTRANGEMAP::const_iterator
CONCURRENTRANGEMAP::find (const key_query_type& key) const
{
  // Return right away if the map's empty;
  const_iterator last = m_last;
  if (!last) return nullptr;

  // Check the last value.
  if (!m_compare (key, last->first)) {
    return last;
  }

  // Do a binary search to find the proper position.
  const_iterator begin = getBegin (last);
  if (!last) return nullptr;
  const_iterator pos = std::upper_bound (begin, last+1, key,
                                         [this](const key_query_type& key2,
                                                const value_type& v)
                                         { return m_compare (key2,v.first); } );

  // Fail if it would be before the first value.
  if (pos == begin) return nullptr;

  // Proper place.
  return pos-1;
}


/**
 * @brief Add a new element to the map.
 * @param range Validity range for this element.
 * @param ptr Payload for this element.
 * @param tryExtend If true, then allow an existing range to be extended
 *                  (see below).
 * @param ctx Execution context.
 *
 * Returns SUCCESS if the new element was successfully inserted.
 * Returns DUPLICATE if the range compared equal to an existing one.
 *         In that case, no new element is inserted (and @c ptr gets deleted).
 * Returns EXTEND if the range of the last element was extended to @c range.
 *         This happens if @c tryExtend is true, @c range is equal
 *         to the range of the last element (according to @c m_compare),
 *         and the range can be extended according to @c extendRange.
 *         (This will generally mean that the start time of @c range
 *         matches the last range, and end time of @c range is after
 *         the end time of the last range.)  In this case, again no
 *         new element is inserted and @c ptr is deleted.
 * Returns OVERLAP if the range of the new element overlaps
 *         an existing element (the new element is still inserted).
 */
T_CONCURRENTRANGEMAP
typename CONCURRENTRANGEMAP::EmplaceResult
CONCURRENTRANGEMAP::emplace (const RANGE& range,
                             payload_unique_ptr ptr,
                             bool tryExtend /*= false*/,
                             const typename Updater_t::Context_t& ctx
                               /*= Updater_t::defaultContext()*/)
{
  lock_t lock (m_mutex);

  value_type* last = m_last;
  value_type* begin = m_begin;

  // Check if the element to be inserted is greater than all existing entries.
  bool pastEnd = (!last || m_compare (last->first, range));

  // Make sure the new element is not a duplicate of the last.  Fail if so.
  if (last && !pastEnd && !m_compare (range, last->first)) {
    // Duplicate of the last entry.
    if (tryExtend) {
      if (extendImpl (lock, range, ctx) > 0) {
        return EmplaceResult::EXTENDED;
      }
    }
    return EmplaceResult::DUPLICATE;
  }

  // Can we add this to the end?
  // There has to be room for another, and either the container must be empty,
  // or the new element must be greater than the current last one.
  value_type* end = last ? last+1 : begin;
  if (pastEnd && end < m_impl->data() + m_impl->capacity())
  {
    // Yes --- copy the data to the container.
    end->first = range;
    end->second = ptr.release();

    std::atomic_thread_fence (std::memory_order_seq_cst);

    // Update the last pointer.
    m_last = end;
    // Now the new element is visible to other threads.
    ++m_nInserts;
    m_maxSize = std::max (m_maxSize, static_cast<size_t> (end+1 - begin));

    // Check for overlap with the previous range.
    if (end > begin && m_compare.overlap ((end-1)->first, range)) {
      return EmplaceResult::OVERLAP;
    }
    return EmplaceResult::SUCCESS;
  }

  // No --- need to make a new implementation object and copy.
  // Make the new one bigger, if needed.
  int new_capacity = m_impl->capacity();
  int old_size = end-begin;
  if (old_size == 0) old_size = 1;
  if (old_size > new_capacity/2) {
    new_capacity = old_size*2;
  }

  EmplaceResult ret = EmplaceResult::SUCCESS;

  // Allocate the new object.
  auto new_impl = std::make_unique<Impl> (m_delete, new_capacity);
  value_type* new_begin = new_impl->data();
  value_type* new_end = new_begin;

  // Copy the data, adding the new item at the proper place.
  // Separate out the case where the new item goes at the end,
  // since we can do that faster.
  if (pastEnd) {
    new_end = std::copy (begin, end, new_end);
    new_end->first = range;
    new_end->second = ptr.release();
    ++new_end;

    if (end > begin && m_compare.overlap ((end-1)->first, range)) {
      ret = EmplaceResult::OVERLAP;
    }
        
  }
  else {
    // Otherwise we need to search for the proper place to insert the new entry.
    while (begin < end) {
      if (ptr && m_compare (range, begin->first)) {
        // Make sure this isn't a duplicate.
        if (begin > m_begin) {
          if (!m_compare ((begin-1)->first, range)) {
            // Duplicate entry; fail.  Everything allocated is held by unique_ptr,
            // so should be cleaned up properly.
            return EmplaceResult::DUPLICATE;
          }
          else if (m_compare.overlap ((begin-1)->first, range)) {
            ret = EmplaceResult::OVERLAP;
          }
        }
        if (m_compare.overlap (range, begin->first)) {
          ret = EmplaceResult::OVERLAP;
        }

        new_end->first = range;
        new_end->second = ptr.release();
        ++new_end;
      }
      *new_end++ = *begin++;
    }

    // Must have dealt with the new element by now.
    assert (!ptr);
  }

  // Install the new implementation.
  installImpl (std::move (new_impl), new_begin, new_end, ctx);

  ++m_nInserts;
  m_maxSize = std::max (m_maxSize, static_cast<size_t> (new_end - new_begin));
  return ret;
}


/**
 * @brief Erase the first item less than or equal to KEY.
 * @param key The key to search erase.
 * @param ctx Execution context.
 */
T_CONCURRENTRANGEMAP
void
CONCURRENTRANGEMAP::erase (const key_query_type& key,
                           const typename Updater_t::Context_t& ctx
                             /*= Updater_t::defaultContext()*/)
{
  lock_t lock (m_mutex);

  // Return if the container's empty.
  value_type* last = m_last;
  if (last == nullptr) return;
  
  value_type* begin = m_begin;
  value_type* end = last+1;

  // Don't do anything if key is before the first element.
  if (m_compare (key, begin->first)) return;

  // Is the first element the one we're deleting?
  if (begin == last || m_compare (key, (begin+1)->first)) {
    // Yes --- queue the payload for deletion.
    m_impl->discard (begin->second);
    ++begin;

    // Make the update visible to other threads.
    // If we need to update both pointers, then clear m_begin first.
    if (begin == end) {
      m_begin = nullptr;
      m_last = nullptr;
    }
    m_begin = begin;
    return;
  }

  // Need to make a new implementation object and copy data.
  size_t capacity = m_impl->capacity();
  auto new_impl = std::make_unique<Impl> (m_delete, capacity);
  value_type* new_begin = new_impl->data();
  value_type* new_end = new_begin;

  // Copy the data, skipping the object to be deleted.
  while (begin < end-1 && !m_compare (key, (begin+1)->first)) {
    *new_end++ = *begin++;
  }
  m_impl->discard (begin->second);
  ++begin;
  while (begin < end) {
    *new_end++ = *begin++;
  }

  // Install the new implementation.
  installImpl (std::move (new_impl), new_begin, new_end, ctx);
}


/**
 * @brief Extend the range of the last entry of the map.
 * @param newRange New range to use for the last entry.
 * @param ctx Execution context.
 *
 * The range of the last entry in the map is updated to @c newRange.
 * Does nothing if the map is empty.
 * This will make a new version of implementation data.
 *
 * The semantics of what it means to extend a range are given by the
 * @c extendRange method of the @c COMPARE object:
 *
 *@code
 *  int extendRange (Range& range, const Range& newRange) const;
 @endif
 *
 * This is called with the existing range and the end range, and returns
 * a flag.  -1 indicates an error, 0 indicates that no change
 * was made to the range, and 1 indicates that the range was extended.
 * It should generally be safe to extend a range by making the end later.
 * Suggested semantics are:
 *  - Return -1 if the start keys don't match.
 *  - If the end value of @c newRange is later then then end value of @c range,
 *    then update the end value of @c range to match @c newRange and
 *    return 1.
 *  - Otherwise do nothing and return 0.
 *
 * Returns -1 if there was an error; 1 if the last range was extended;
 * and 0 if nothing was changed.
 */
T_CONCURRENTRANGEMAP
int
CONCURRENTRANGEMAP::extendLastRange (const RANGE& newRange,
                                     const typename Updater_t::Context_t& ctx
                                     /*= Updater_t::defaultContext()*/)
{
  lock_t lock (m_mutex);
  return extendImpl (lock, newRange, ctx);
}


/**
 * @brief Update all range objects.
 * @param rangeUpater Functional to call on each range object.
 * @param ctx Execution context.
 *
 * This will iterate through the list of entries and call @c rangeUpdater
 * on the @c RANGE part of each.  Be careful: rangeUpdater must not
 * change any part of the range which might affect the sorting
 * of entries.
 */
T_CONCURRENTRANGEMAP
void
CONCURRENTRANGEMAP::updateRanges (std::function<void (RANGE&)> rangeUpdater,
                                  const typename Updater_t::Context_t& ctx
                                   /*= Updater_t::defaultContext()*/)
{
  lock_t lock (m_mutex);

  // Return if the container's empty.
  value_type* last = m_last;
  if (last == nullptr) return;

  // Make a new implementation object and copy data.
  size_t capacity = m_impl->capacity();
  auto new_impl = std::make_unique<Impl> (m_delete, capacity);
  value_type* new_begin = new_impl->data();
  value_type* new_end = new_begin;
  value_type* begin = m_begin;
  value_type* end = m_last+1;
  new_end = std::copy (begin, end, new_end);

  // Update ranges in the new copy.
  for (value_type* v = new_begin; v != new_end; ++v) {
    rangeUpdater (v->first);
  }

  // Install the new implementation.
  installImpl (std::move (new_impl), new_begin, new_end, ctx);
}


/**
 * @brief Extend the range of the last entry of the map.
 * @param Lock object.
 * @param newRange New range to use for the last entry.
 * @param ctx Execution context.
 *
 * Implementation of @c extendLastRange; see there for details.
 * Must be called with the lock held.
 */
T_CONCURRENTRANGEMAP
int
CONCURRENTRANGEMAP::extendImpl (lock_t& /*lock*/,
                                const RANGE& newRange,
                                const typename Updater_t::Context_t& ctx)
{
  // Return if the container's empty.
  value_type* last = m_last;
  if (last == nullptr) return -1;

  // Test the range.
  RANGE extendedRange = last->first;
  int flag = m_compare.extendRange (extendedRange, newRange);

  if (flag < 0) {
    // Error.
    return -1;
  }
  else if (flag == 0) {
    // No-op.
    return 0;
  }

  // Make a new implementation object and copy data.
  size_t capacity = m_impl->capacity();
  auto new_impl = std::make_unique<Impl> (m_delete, capacity);
  value_type* new_begin = new_impl->data();
  value_type* new_end = new_begin;
  value_type* begin = m_begin;
  value_type* end = m_last+1;
  new_end = std::copy (begin, end, new_end);

  // Update the range of the last entry.
  (new_end-1)->first = extendedRange;

  // Install the new implementation.
  installImpl (std::move (new_impl), new_begin, new_end, ctx);

  return 1;
}

                           
/**
 * @brief Remove unused entries from the front of the list.
 * @param keys List of keys that may still be in use.
 *             (Must be sorted.)
 *
 * We examine the objects in the container, starting with the earliest one.
 * If none of the keys in @c keys match the range for this object, then
 * it is removed from the container.  We stop when we either find
 * an object with a range matching a key in @c keys or when there
 * is only one object left.
 *
 * Removed objects are queued for deletion once all slots have been
 * marked as quiescent.
 *
 * The list @c keys MUST be sorted.
 *
 * Returns the number of objects that were removed.
 */
T_CONCURRENTRANGEMAP
size_t
CONCURRENTRANGEMAP::trim (const std::vector<key_query_type>& keys)
{
  size_t ndel = 0;

  lock_t lock (m_mutex);

  // Return immediately if the container is empty.
  value_type* last = m_last;
  if (last == nullptr) return ndel;
  
  value_type* pos = m_begin;

  // If we remove objects, stick them in a dummy Impl object, and then
  // discard that.  FIXME: It's a bit funny to have to allocate an object
  // in order to delete stuff.  Maybe RCUObject could be taught to manage
  // objects of multiple types?
  std::unique_ptr<Impl> garbage;

  // Compare with last rather than end=last+1; we don't want to consider
  // the last elt.
  while (pos < last) {
    // FIXME: Can use the position where we found the last one as a hint?
    if (anyInRange (pos->first, keys)) {
      // One of the keys matched the range of this object.  Stop here.
      break;
    }

    // We're deleting the object now.

    if (!garbage) {
      // Allocate a dummy impl object if we haven't done so yet.
      garbage = std::make_unique<Impl> (m_delete, 0);
    }

    // Add it to the garbage list.
    garbage->discard (pos->second);
    ++ndel;
    ++pos;
  }

  // If we've deleted any object, then update the begin pointer and
  // queue the dummy impl object for destruction.
  if (ndel > 0) {
    // Important: m_begin must be updated _before_ the discard() call.
    m_begin = pos;
    m_updater.discard (std::move (garbage));
  }

  return ndel;
}


/**
 * @brief Return the current number of elements in the map.
 */
T_CONCURRENTRANGEMAP
inline
size_t CONCURRENTRANGEMAP::size() const
{
  const_iterator last = m_last;
  if (!last) return 0;
  const_iterator begin = getBegin (last);
  if (!last) return 0;
  return last+1 - begin;
}


/**
 * @brief Test if the map is empty.
 */
T_CONCURRENTRANGEMAP
inline
bool CONCURRENTRANGEMAP::empty() const
{
  return m_last == nullptr;
}


/**
 * @brief Return the current capacity of the map.
 */
T_CONCURRENTRANGEMAP
inline
size_t CONCURRENTRANGEMAP::capacity() const
{
  return m_updater.get().capacity();
}


/**
 * @brief Return the number times an item was inserted into the map.
 */
T_CONCURRENTRANGEMAP
inline
size_t CONCURRENTRANGEMAP::nInserts() const
{
  return m_nInserts;
}


/**
 * @brief Return the maximum size of the map.
 */
T_CONCURRENTRANGEMAP
inline
size_t CONCURRENTRANGEMAP::maxSize() const
{
  return m_maxSize;
}


/**
 * @brief Return a range that can be used to iterate over the container.
 */
T_CONCURRENTRANGEMAP
inline
typename CONCURRENTRANGEMAP::const_iterator_range
CONCURRENTRANGEMAP::range() const
{
  const_iterator last = m_last;
  if (!last) return const_iterator_range (nullptr, nullptr);
  const_iterator begin = getBegin (last);
  if (!last) return const_iterator_range (nullptr, nullptr);
  return const_iterator_range (begin, last+1);
}


/**
 * @brief Called when this thread is no longer referencing anything
 *        from this container.
 * @param ctx Execution context.
 */
T_CONCURRENTRANGEMAP
void
CONCURRENTRANGEMAP::quiescent (const typename Updater_t::Context_t& ctx /*= Updater_t::defaultContext()*/)
{
  m_updater.quiescent (ctx);
}


/**
 * @brief Return the deletion function for this container.
 */
T_CONCURRENTRANGEMAP
inline
typename CONCURRENTRANGEMAP::delete_function*
CONCURRENTRANGEMAP::delfcn() const
{
  return m_delete;
}


/**
 * @brief Return the begin/last pointers.
 * @param [inout] last Current value of last.
 *
 * Retrieve consistent values of the begin and last pointers.
 * The last pointer should have already been fetched, and may be updated.
 * Usage should be like this:
 *
 *@code
 *  const_iterator last = m_last;
 *  if (!last) return;  // Container empty.
 *  const_iterator begin = getBegin (last);
 *  if (!last) return;  // Container empty.
 @endcode
*/
T_CONCURRENTRANGEMAP
inline
typename CONCURRENTRANGEMAP::const_iterator
CONCURRENTRANGEMAP::getBegin (const_iterator& last) const
{
  // First fetch the begin pointer, then check that both there is not
  // an update in progress and that the last pointer
  // hasn't changed.  In either case, we need to refetch both pointers.
  // ABA isn't an issue here since the pointers go only in one direction,
  // and if we allocate a new chunk, it will be in a disjoint
  // piece of memory.
  const_iterator begin;
  while (true) {
    begin = m_begin;
    if (begin && last == m_last) break;
    CxxUtils::stall();
    last = m_last;
  }
  return begin;
}


/**
 * @brief Consistently update both the begin and last pointers.
 * @param begin New begin pointer.
 * @param end New end pointer.
 */
T_CONCURRENTRANGEMAP
inline
void
CONCURRENTRANGEMAP::updatePointers (value_type* new_begin, value_type* new_end)
{
  // Mark that there's an update in progress.
  m_begin = nullptr;
  // Then update the last pointer.
  if (new_begin == new_end) {
    m_last = nullptr;
  }
  else {
    m_last = new_end-1;
  }
  // Then set the begin pointer.
  m_begin = new_begin;
}


/**
 * @brief Test to see if any keys within @c keys match @c r.
 * @brief r Range to test.
 * @break keys List of keys to test.  MUST be sorted.
 */
T_CONCURRENTRANGEMAP
bool
CONCURRENTRANGEMAP::anyInRange (const key_type& r,
                                const std::vector<key_query_type>& keys) const
{
  auto pos = std::lower_bound (keys.begin(), keys.end(), r, m_compare);
  return pos != keys.end() && m_compare.inRange (*pos, r);
}


/**
 * @brief Install a new implementation instance and make it visible.
 * @param new_impl The new instance.
 * @param new_begin Begin pointer for the new instance.
 * @param new_end End pointer for the new instance.
 *                (Usual STL meaning of end.  If the instance is empty,
 *                then new_end should match new_begin.)
 * @param ctx Execution context.
 */
T_CONCURRENTRANGEMAP
inline
void
CONCURRENTRANGEMAP::installImpl (std::unique_ptr<Impl> new_impl,
                                 value_type* new_begin,
                                 value_type* new_end,
                                 const typename Updater_t::Context_t& ctx)
{
  // Install the new implementation.
  m_impl = new_impl.get();

  // Make the update visible to other threads.
  // Make sure not to add the old version to the garbage list before
  // we've updated the pointers.
  updatePointers (new_begin, new_end);
  m_updater.update (std::move (new_impl), ctx);
}


#undef T_CONCURRENTRANGEMAP
#undef CONCURRENTRANGEMAP


} // namespace CxxUtils
