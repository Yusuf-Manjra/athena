#!/bin/bash

# use this to enable bash script debugging:
#set -x

PROGNAME=${0##*/}

# the preincludes used for the differend possible profilerModes
EVENTLOOP_PREINCLUDE="PerfMonGPerfTools/ProfileEventLoop_preInclude.py"
JOB_PREINCLUDE="PerfMonGPerfTools/ProfileJob_preInclude.py"

# using this post-include makes the GPT more stable
POSTINCLUDE="PerfMonGPerfTools/DisableCoreDumpSvc_postInclude.py"


#
# help output function
#
usage()
{ 
  echo "Usage: $PROGNAME [options]"
  echo ""
  echo "Options:"
  echo " -h|--help                 show this output"
  echo " -v|--profilerVersion      display version of PerfMonGPerfTools used for profiling"
  echo " --trf \"TRFCMD\"          run on a job transform script"
  echo " --tf \"TFCMD\"            run on a new job transform script"
  echo " --profilerMode MODE       defines which part of the program will be profiled"
  echo "                           Allowed values for MODE are:"
  echo "                             eventLoop  for profiling on the Athena eventLoop (default)"
  echo "                             job        run profiling on the whole Athena job"
  echo " --profilerInitEvent EVT   in 'eventLoop' Mode, define the event number after which profiling starts"
  echo " --profilerOutput OUT      pofiler output file"
}



# by default, run profiling on the event loop
# (will be overwritten in case a --profilerMode argument is given)
PREINCLUDE=${EVENTLOOP_PREINCLUDE}


#########################
# 
# loop over all command line arguments
#
#########################
NUM_ATHENA_ARGS=0
set -- "$@"
while [ $# -gt 0 ]; do 

  case $1 in 
    -h|--help)
      # call the 'usage' function to print the help output
      usage 
      exit 0 
      ;; 

    --profilerInitEvent)
      shift 
      INITEVENT=${1}
      ;; 

    --profilerOutput)
      shift 
      OUTPUTFILE=${1}
      ;; 

    --profilerMode)
      shift 
      MODE=${1}
      # choose the right jobOptions fragment which adds GPerfTool to athena run
      case $MODE in
        eventLoop)
          PREINCLUDE=${EVENTLOOP_PREINCLUDE}
          ;;
        job)
          PREINCLUDE=${JOB_PREINCLUDE}
          ;;
        *)
          echo "PerfMonGPerfTools: ERROR: Unknown profilerMode given!"
          exit 1
          break
          ;;
      esac
      ;; 

    --trf)
      shift 
      TRFCOMMAND=${1}
      ;; 

    --tf)
      shift 
      TFCOMMAND=${1}
      ;; 

    *)
      # the current argument is not recognized as a gathena argument
      # -> pass it to athena later on (store in ATHENAARGS)
      ATHENAARGS[NUM_ATHENA_ARGS]=$1
      ((NUM_ATHENA_ARGS++))
      ;; 

  esac 
  shift 
done

# remove all remaining arguments form the ${@} variable
#  -> required because they would be picked up later by the source command
for dummy in ${@}; do
  shift
done

###########################
#
# create a local file, used as jobOptions fragment
#
###########################
JOFRAGMENT=gathena_preInclude_autoGen.py
echo "# this jobOptions fragment is automatically generated by ${PROGNAME}" > $JOFRAGMENT
echo "include ('${PREINCLUDE}')" >> $JOFRAGMENT
# output filename was set by a command line argument
if [ -n "${OUTPUTFILE}" ]; then
  echo "ServiceMgr.ProfilerService.ProfileFileName='${OUTPUTFILE}'" >> $JOFRAGMENT
fi
# init event was set by a command line argument and event loop profiling is activated
if [[ -n "${INITEVENT}" && "${PREINCLUDE}" == "${EVENTLOOP_PREINCLUDE}" ]]; then
  echo "ServiceMgr.ProfilerService.InitEvent=${INITEVENT}" >> $JOFRAGMENT
fi


###########################
#
# if non-empty TRFCOMMAND string -> prepare running on a jobTransform
#
###########################
if [ -n "${TRFCOMMAND}" ]; then
  echo "PerfMonGPerfTools: Preparing PerfMonGPerfTools for running with a job transform script"

  # if TRFCOMMAND contains a preInclude already -> prepend PerfMonGPerfTools preinclude
  if [[ ${TRFCOMMAND} == *" preInclude="* ]]; then
    TRFCOMMAND=${TRFCOMMAND/ preInclude=/ preInclude=${JOFRAGMENT},}
  # no preInclude argument given by the user -> add preInclude argument
  else
    TRFCOMMAND="${TRFCOMMAND} preInclude=${JOFRAGMENT}"
  fi

  # if TRFCOMMAND contains a posInclude already -> prepend PerfMonGPerfTools postinclude
  if [[ ${TRFCOMMAND} == *" postInclude="* ]]; then
    TRFCOMMAND=${TRFCOMMAND/ postInclude=/ postInclude=${POSTINCLUDE},}
  # no postInclude argument given by the user -> add postInclude argument
  else
    TRFCOMMAND="${TRFCOMMAND} postInclude=${POSTINCLUDE}"
  fi
fi


###########################
#
# if non-empty TFCOMMAND string -> prepare running on a jobTransform
#
###########################
if [ -n "${TFCOMMAND}" ]; then
  echo "PerfMonGPerfTools: Preparing PerfMonGPerfTools for running with a job transform script"

  # if TFCOMMAND contains a preInclude already -> prepend PerfMonGPerfTools preinclude
  if [[ ${TFCOMMAND} == *" --preInclude="* ]]; then
    TFCOMMAND=${TFCOMMAND/ --preInclude=/ --preInclude=${JOFRAGMENT},}
  # no preInclude argument given by the user -> add preInclude argument
  else
    TFCOMMAND="${TFCOMMAND} --preInclude=${JOFRAGMENT}"
  fi

  # if TFCOMMAND contains a posInclude already -> prepend PerfMonGPerfTools postinclude
  if [[ ${TFCOMMAND} == *" --postInclude="* ]]; then
    TFCOMMAND=${TFCOMMAND/ --postInclude=/ --postInclude=${POSTINCLUDE},}
  # no postInclude argument given by the user -> add postInclude argument
  else
    TFCOMMAND="${TFCOMMAND} --postInclude=${POSTINCLUDE}"
  fi
fi


#########################
#
# execute the actual athena job / jobTransform
#
#########################
echo "PerfMonGPerfTools: Will now run PerfMonGPerfTools on the defined Athena job:"

# (a) run job transform
if [ -n "${TRFCOMMAND}" ]; then
  echo "PerfMonGPerfTools:  -> ${TRFCOMMAND}"
  ${TRFCOMMAND}
  EXITCODE=$?

# (b) run new job transform
elif [ -n "${TFCOMMAND}" ]; then
  echo "PerfMonGPerfTools:  -> ${TFCOMMAND}"
  ${TFCOMMAND}
  EXITCODE=$?

# (c) run athena.py directly
else
  echo PerfMonGPerfTools:  "->" athena.py "${ATHENAARGS[@]}" ${JOFRAGMENT} ${POSTINCLUDE}
  athena.py  "${ATHENAARGS[@]}" ${JOFRAGMENT} ${POSTINCLUDE}
  EXITCODE=$?
fi

# make sure this script retuns with the same exit code as the athena job
exit ${EXITCODE}
