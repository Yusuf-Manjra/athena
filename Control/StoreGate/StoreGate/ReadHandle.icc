///////////////////////// -*- C++ -*- /////////////////////////////

/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// ReadHandle.icc
// Implementation file for class SG::ReadHandle<T>
// Author: S.Binet<binet@cern.ch>
/////////////////////////////////////////////////////////////////// 
#ifndef STOREGATE_SG_READHANDLE_ICC
#define STOREGATE_SG_READHANDLE_ICC 1

// stl includes
#include <stdexcept>

// fwk includes
#include "AthenaKernel/IProxyDict.h"
#include "AthenaKernel/IResetable.h"

// SGTools includes
#include "SGTools/ClassID_traits.h"
#include "SGTools/DataBucketBase.h"

// StoreGate includes
#include "StoreGate/VarHandleBase.h"

namespace SG {

/////////////////////////////////////////////////////////////////// 
// Public methods: 
/////////////////////////////////////////////////////////////////// 

// Constructors
////////////////

/// Default constructor: 
template <class T> 
ReadHandle<T>::ReadHandle() : 
  VarHandleBase()
{ }

/// Copy constructor: 
template <class T> 
ReadHandle<T>::ReadHandle(const ReadHandle& h):
  VarHandleBase(h)
{}

/// Assignment operator: 
template <class T>
ReadHandle<T>& 
ReadHandle<T>::ReadHandle::operator= (const ReadHandle& h)
{
  if (this != &h) {
    this->VarHandleBase::operator=(h);
  }
  return *this;
}

/// Copy constructor: 
template <class T> 
ReadHandle<T>::ReadHandle(ReadHandle&& h):
  VarHandleBase(std::move(h))
{}

/// Assignment operator: 
template <class T>
ReadHandle<T>& 
ReadHandle<T>::ReadHandle::operator= (ReadHandle&& h)
{
  if (this != &h) {
    this->VarHandleBase::operator=(std::move(h));
  }
  return *this;
}

/// retrieve a proxy of name `name` from evtStore
template <class T>
ReadHandle<T>::ReadHandle(const IInterface* /*iface*/,
              const std::string& name) :
  VarHandleBase( name )
{}

/// retrieve a proxy of name `name` from evtStore
template <class T>
ReadHandle<T>::ReadHandle(const IInterface* /*iface*/,
              const std::string& name,
              const std::string& store) :
  VarHandleBase( name, store )
{}


/// retrieve a proxy of name `name` from evtStore
template <class T>
ReadHandle<T>::ReadHandle(const std::string& name) :
  VarHandleBase( name )
{}

/// retrieve a proxy of name `name` from store `store`
template <class T>
ReadHandle<T>::ReadHandle(const std::string& name,
              const std::string& store) :
  VarHandleBase( name, store )
{}

/// Destructor: 
template <class T> 
ReadHandle<T>::~ReadHandle()
{ 
} 

} /* namespace SG */

#endif //> !STOREGATE_SG_READHANDLE_ICC
