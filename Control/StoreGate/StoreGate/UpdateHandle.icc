///////////////////////// -*- C++ -*- /////////////////////////////

/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// UpdateHandle.icc
// Implementation file for class SG::UpdateHandle<T>
// Author: S.Binet<binet@cern.ch>
/////////////////////////////////////////////////////////////////// 
#ifndef STOREGATE_SG_UPDATEHANDLE_ICC
#define STOREGATE_SG_UPDATEHANDLE_ICC 1

// stl includes
#include <stdexcept>

// fwk includes
#include "AthenaKernel/IProxyDict.h"
#include "AthenaKernel/IResetable.h"

// SGTools includes
#include "SGTools/ClassID_traits.h"
#include "SGTools/DataBucketBase.h"

// StoreGate includes
#include "StoreGate/VarHandleBase.h"

namespace SG {

/////////////////////////////////////////////////////////////////// 
// Public methods: 
/////////////////////////////////////////////////////////////////// 

// Constructors
////////////////

/// Default constructor: 
template <class T> 
UpdateHandle<T>::UpdateHandle() : 
  VarHandleBase()
{ setMode(Gaudi::DataHandle::Updater); }

/// Copy constructor: 
template <class T> 
UpdateHandle<T>::UpdateHandle(const UpdateHandle& h):
  VarHandleBase(h)
{ }

/// Assignment operator: 
template <class T>
UpdateHandle<T>& 
UpdateHandle<T>::UpdateHandle::operator= (const UpdateHandle& h)
{
  if (this != &h) {
    this->VarHandleBase::operator=(h);
  }
  return *this;
}

/// Move constructor: 
template <class T> 
UpdateHandle<T>::UpdateHandle(UpdateHandle&& h):
  VarHandleBase(std::move(h))
{}

/// Assignment move operator: 
template <class T>
UpdateHandle<T>& 
UpdateHandle<T>::UpdateHandle::operator= (UpdateHandle&& h)
{
  if (this != &h) {
    this->VarHandleBase::operator=(std::move(h));
  }
  return *this;
}

template <class T>
UpdateHandle<T>& 
UpdateHandle<T>::UpdateHandle::operator= (const T& data)
{
  if (!isInitialized() && !(setState().isSuccess())) {
    throw std::logic_error
      ("UpdateHandle<T>::operator=(const T& data) can not initialize handle");
  }
  if (!isConst()) {
    this->reset(false);
  }
  T* val = this->ptr();
  if (!val) {
    throw std::logic_error
      ("UpdateHandle<T>::operator=(const T& data) called while invalid");
  }

  *val = data;
  if (m_store->updatedObject (this->clid(), this->name()).isFailure()) {
    throw std::logic_error
      ("UpdateHandle<T>::operator=(const T& data) updatedObject returns failure.");
  }

  return *this;
}

/// retrieve a proxy of name `name` from evtStore
template <class T>
UpdateHandle<T>::UpdateHandle(const IInterface* /*iface*/,
                const std::string& name) :
  VarHandleBase( name, Gaudi::DataHandle::Updater )
{}

/// retrieve a proxy of name `name` from evtStore
template <class T>
UpdateHandle<T>::UpdateHandle(const IInterface* /*iface*/,
                const std::string& name,
                const std::string& store) :
  VarHandleBase( name, Gaudi::DataHandle::Updater, store )
{}


/// retrieve a proxy of name `name` from evtStore
template <class T>
UpdateHandle<T>::UpdateHandle(const std::string& name) :
  VarHandleBase( name, Gaudi::DataHandle::Updater )
{}

/// retrieve a proxy of name `name` from store `store`
template <class T>
UpdateHandle<T>::UpdateHandle(const std::string& name,
                const std::string& store) :
  VarHandleBase( name, Gaudi::DataHandle::Updater, store )
{}

/// Destructor: 
template <class T> 
UpdateHandle<T>::~UpdateHandle()
{ 
} 
} /* namespace SG */

#endif //> !STOREGATE_SG_UPDATEHANDLE_ICC
