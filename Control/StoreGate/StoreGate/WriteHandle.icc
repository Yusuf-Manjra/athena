///////////////////////// -*- C++ -*- /////////////////////////////

/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// WriteHandle.icc
// Implementation file for class SG::WriteHandle<T>
/////////////////////////////////////////////////////////////////// 
#ifndef STOREGATE_SG_WRITEHANDLE_ICC
#define STOREGATE_SG_WRITEHANDLE_ICC 1

// stl includes
#include <stdexcept>

// fwk includes
#include "AthenaKernel/IProxyDict.h"
#include "AthenaKernel/IResetable.h"

// SGTools includes
#include "SGTools/ClassID_traits.h"
#include "SGTools/DataBucketBase.h"

// StoreGate includes
#include "StoreGate/VarHandleBase.h"
#include "StoreGate/StoreGateSvc.h"

namespace SG {

/////////////////////////////////////////////////////////////////// 
// Public methods: 
/////////////////////////////////////////////////////////////////// 

// Constructors
////////////////

/// Default constructor: 
template <class T> 
WriteHandle<T>::WriteHandle() : 
  VarHandleBase()
{ setMode(Gaudi::DataHandle::Writer); }

/// Copy constructor: 
template <class T> 
WriteHandle<T>::WriteHandle(const WriteHandle& h):
  VarHandleBase(h)
{ }

/// Assignment operator: 
template <class T>
WriteHandle<T>& 
WriteHandle<T>::WriteHandle::operator= (const WriteHandle& h)
{
  if (this != &h) {
    this->VarHandleBase::operator=(h);
  }
  return *this;
}

/// Move constructor: 
template <class T> 
WriteHandle<T>::WriteHandle(WriteHandle&& h):
  VarHandleBase(std::move(h))
{}

/// Assignment move operator: 
template <class T>
WriteHandle<T>& 
WriteHandle<T>::WriteHandle::operator= (WriteHandle&& h)
{
  if (this != &h) {
    this->VarHandleBase::operator=(std::move(h));
  }
  return *this;
}

template <class T>
WriteHandle<T>& 
WriteHandle<T>::WriteHandle::operator= (const T& data)
{
  if (!isInitialized()) {
    throw std::logic_error
      ("WriteHandle<T>::operator=(const T& data) called while un-initialized");
  }
  T* val = this->ptr();
  if (!val) {
    throw std::logic_error
      ("WriteHandle<T>::operator=(const T& data) called while invalid");
  }
  
  *val = data;
  return *this;
}

template <class T>
WriteHandle<T>& 
WriteHandle<T>::WriteHandle::operator= (std::unique_ptr<T> data)
{
  if (!m_store) {
    if (m_storeHandle.retrieve().isFailure())
      throw std::runtime_error ("WriteHandle<T>::operator=(unique_ptr) can't find event store");
    m_store = m_storeHandle.get();
  }

  // make sure the BaseInfo(Base) structure is initialized
  SG::BaseInfo<T>::baseinfo();

  // If s_isConst is set for this type, then we want to automatically
  // make it const when recorded.
  bool allowMods = true;
  if (ClassID_traits<T>::s_isConst)
    allowMods = false;

 // record into storegate
  T* dataPtr(data.release());

  std::unique_ptr<DataObject> dobj (SG::asStorable (dataPtr));
  SG::DataProxy* new_proxy = 
     m_store->recordObject (std::move(dobj), this->name(), allowMods);
  if (!new_proxy) throw std::runtime_error(
	   "WriteHandle<T>::operator=(unique_ptr) error initializing");
  if (m_proxy != new_proxy) {
    if (setState (new_proxy).isFailure())
      throw std::runtime_error(
                               "WriteHandle<T>::operator=(unique_ptr) setting state");
  }
  m_ptr=(void*)dataPtr;
  return *this;
}

/// retrieve a proxy of name `name` from evtStore
template <class T>
WriteHandle<T>::WriteHandle(const std::string& name) :
  VarHandleBase( name, Gaudi::DataHandle::Writer )
{}

/// retrieve a proxy of name `name` from store `store`
template <class T>
WriteHandle<T>::WriteHandle(const std::string& name,
	      const std::string& store) :
  VarHandleBase( name, Gaudi::DataHandle::Writer, store)
{}

/// Destructor: 
template <class T> 
WriteHandle<T>::~WriteHandle()
{ 
} 

} /* namespace SG */

#endif //> !STOREGATE_SG_WRITEHANDLE_ICC
