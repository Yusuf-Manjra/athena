///////////////////////// -*- C++ -*- /////////////////////////////

/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// WriteHandle.icc
// Implementation file for class SG::WriteHandle<T>
/////////////////////////////////////////////////////////////////// 
#ifndef STOREGATE_SG_WRITEHANDLE_ICC
#define STOREGATE_SG_WRITEHANDLE_ICC 1

// stl includes
#include <stdexcept>

// fwk includes
#include "AthenaKernel/IProxyDict.h"
#include "AthenaKernel/IResetable.h"

// SGTools includes
#include "SGTools/ClassID_traits.h"
#include "SGTools/DataBucketBase.h"

// StoreGate includes
#include "StoreGate/VarHandleBase.h"
#include "StoreGate/StoreGateSvc.h"

namespace SG {

/////////////////////////////////////////////////////////////////// 
// Public methods: 
/////////////////////////////////////////////////////////////////// 

// Constructors
////////////////

/// Default constructor: 
template <class T> 
WriteHandle<T>::WriteHandle() : 
  VarHandleBase()
{ }

/// Copy constructor: 
template <class T> 
WriteHandle<T>::WriteHandle(const WriteHandle& h):
  VarHandleBase(h)
{}

/// Assignment operator: 
template <class T>
WriteHandle<T>& 
WriteHandle<T>::WriteHandle::operator= (const WriteHandle& h)
{
  if (this != &h) {
    this->VarHandleBase::operator=(h);
  }
  return *this;
}

/// Move constructor: 
template <class T> 
WriteHandle<T>::WriteHandle(WriteHandle&& h):
  VarHandleBase(std::move(h))
{}

/// Assignment move operator: 
template <class T>
WriteHandle<T>& 
WriteHandle<T>::WriteHandle::operator= (WriteHandle&& h)
{
  if (this != &h) {
    this->VarHandleBase::operator=(std::move(h));
  }
  return *this;
}

template <class T>
WriteHandle<T>& 
WriteHandle<T>::WriteHandle::operator= (const T& data)
{
  if (!isInitialized()) {
    throw std::logic_error
      ("WriteHandle<T>::operator=(const T& data) called while un-initialized");
  }
  T* val = this->ptr();
  if (!val) {
    throw std::logic_error
      ("WriteHandle<T>::operator=(const T& data) called while invalid");
  }
  
  *val = data;
  return *this;
}

template <class T>
WriteHandle<T>& 
WriteHandle<T>::WriteHandle::operator= (std::unique_ptr<T> data)
{
  if (!isInitialized()) {
    // record into storegate
    StoreGateSvc& svc(dynamic_cast<StoreGateSvc&>(*m_store));
    T* dataPtr(data.release());
    m_ptr=(void*)dataPtr;
    StatusCode sc = svc.record<T>(dataPtr, this->name());
    if (sc.isSuccess()) sc = setState();
    if (!(sc.isSuccess())) throw
      std::runtime_error("WriteHandle<T>::operator=(unique_ptr) error initializing");
  } else {
    reset();
    T* dataPtr(data.release());
    m_ptr=(void*)dataPtr;
    this->m_proxy->setObject(SG::asStorable<T>(dataPtr));
    this->m_proxy->registerTransient(m_ptr);
  }
  return *this;
}

/// retrieve a proxy of name `name` from evtStore
template <class T>
WriteHandle<T>::WriteHandle(const std::string& name) :
  VarHandleBase( name )
{}

/// retrieve a proxy of name `name` from store `store`
template <class T>
WriteHandle<T>::WriteHandle(const std::string& name,
	      const std::string& store) :
  VarHandleBase( name, store )
{}

/// Destructor: 
template <class T> 
WriteHandle<T>::~WriteHandle()
{ 
} 

} /* namespace SG */

#endif //> !STOREGATE_SG_WRITEHANDLE_ICC
