/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/


#include "FourMomUtils/P4Helpers.h"
#include "AthenaKernel/errorcheck.h"

namespace TrigTauTool {

/********************************************
 * Functions for the TrigReadNav Tool Class 
 ********************************************/

template<typename O, typename C>
std::vector<const O*> TrigReadNavTool::getRelations(const C* p, std::string& fromlabel, std::string& tolabel){
   std::vector<const O*> relations;

   TrigReadNavTool::DatCacheT<O,C> datT(&m_trigDec, m_chainPattern, m_onlyPassed);
   datT.SetObjectLabels(fromlabel, tolabel);
   datT.fillobjTorelations();

   typename std::map< const C*, std::vector<const O*> >::const_iterator it;
   it = (datT.m_objTorelations).find(p);
   if( it!=(datT.m_objTorelations).end() ){
      const C* o = (*it).first;
      if( datT.isSamePtr(o,p) ) 
         relations = (*it).second;
   }
   return relations;
}

/******************************************************
 * functions for DatCacheT                               
 ******************************************************/

/* functions for obj to obj(s) nav matching */

template<typename O, typename C>
void TrigReadNavTool::DatCacheT<O,C>::fillobjTorelations(){
   m_chainGroup = (*m_trigDec)->getChainGroup(m_chainPattern);
   Trig::FeatureContainer f = m_chainGroup->features(TrigDefs::alsoDeactivateTEs);
   BOOST_FOREACH( const Trig::Combination& comb, f.getCombinations() ) {
      BOOST_FOREACH( const HLT::TriggerElement* te, comb.tes() ){
         const C* obj = (*m_trigDec)->ancestor<C>(te, m_fromlabel);
         const O* rel = (*m_trigDec)->ancestor<O>(te, m_tolabel);
         if(obj!=0 && rel!=0){
            if( m_objTorelations.find(obj)==m_objTorelations.end() ){
               std::vector<const O*> rels;
	       rels.push_back(rel);
               m_objTorelations.insert( std::pair< const C*, std::vector<const O*> >(obj, rels) );
            } else {
               std::vector<const O*> rels = (m_objTorelations.find(obj))->second;
               rels.push_back(rel);
               m_objTorelations.erase(obj);
               m_objTorelations.insert( std::pair< const C*, std::vector<const O*> >(obj, rels) );
            } // if( m_objtorelations.find...
         } // if(obj!=0... 
      } // BOOST... te...
   } //BOOST... comb
return;
}

} // end of namespace
