\documentclass[a4paper,11pt]{article}

\usepackage[a4paper]{geometry}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{rotating,multirow}
\usepackage{hyperref}

\title{Linear Fit within Missing-Hit Roads in FTKSim}
\author{A.~Annovi, F.~Crescioli, M.~Dell'Orso, P.~Giannetti, G.~Punzi, G.~Volpi}

\begin{document}
\maketitle

\section{Fitting missing-hit tracks}
\label{sec:idea}

The linear fit, as proposed for the FTK track fitter (TF) \cite{FTK-IEEE-1},
evaluates each track parameter $p$ by using the equation:
\begin{equation}
  \label{eq:fit}
  p = \vec c \cdot \vec x + q
\end{equation}
where $\vec c$ and $q$ are fit constants (FCs) for the given sector
\cite{SVT-TDR} 
to which the $\vec x$ components, namely the hit {\em coordinates}, belong.
The number $N$ of coordinates
is the number of strip detector layers plus twice the number of
pixel detector layers used in the fit.
In parallel with the track parameters,
the TF also evaluates a fit-quality estimator $\chi^2$:
\begin{equation}
  \label{eq:chi2}
  \chi^2 = \sum_{i=1}^{N_f} \left[ \left( \sum_{j=1}^N S_{ij} \, x_j \right) + h_i \right]^2
\end{equation}
where the sum indices are explicit,
$S$ is a rectangular matrix of size $N_f \times N = (N-N_p) \times N$,
$\vec h$ is a constant vector of size $N_f$,
$N_p$ is the number of track parameters,
and $N_f$ is the number of track constraints ($\chi^2$ degrees of freedom).
$S$ and $\vec h$ are additional FCs for the given sector.

For each sector a total of
$N_p \times (N+1) + N_f \times (N+1) = N \times (N+1)$
pre-calculated FCs result from (1) and (2).
In the current configuration $N=14$, $N_p=5$, and $N_f=9$
\cite{Brubaker:2007rk}. 
These numbers, multiplied by about 300,000 sectors, mean that we need
a set of at least $6.3 \times 10^7$ FCs to be stored somewhere.

It is important to remark that the dimensions of the arrays in
\eqref{eq:fit} and \eqref{eq:chi2} are fixed.
This entails that only roads with hits on every layer can be processed
this way with the given FC set.
Thus, any single-module inefficiency would result in inefficiency of the
tracking algorithm.

A practical solution to this problem is to admit also missing-hit roads,
by progressively reducing the number of used coordinates to
$N-1$, $N-2$, etc\ldots \ \ 
However, each case must be processed separately,
since {\em the FCs depend on the number of coordinates
as well as on the identity of the missing layers}.
In this approach the FC storage quickly becomes an issue.
For instance, in order to process all roads having any single missing hit,
the number of additional $6.3 \times 10^7$-manifold FC sets would be $N$, i.e. one set
for each possibly missing coordinate
\footnote{Actually, this example is true for $N$ independent
measurements only. The case of the pixel detectors, with $x-y$ correlated
measurements, unfolds with slightly different mathematical details}.



\section{Reclaiming $N$-hit FCs}
\label{sec:formulas}

In order to circumvent the disruptive increase of memory demand,
FTKSim currently reclaims the $N$-hit FCs for use with
$N'$-hit roads, where $N' < N$ is the number of actually
measured coordinates.
The procedure, which exploits the strong coordinate correlations
arising from the membership to the same real trajectory, will be
referred to as {\em guessing hits}. Once the missing coordinates
are guessed, the incomplete $\vec x$ vector can be filled with
the guessed values up to dimension $N$, then the standard $N$-hit FCs
can be used in order to calculate the track parameters with (1).

A good guess for the missing hits is to position them exactly where
they would minimize the $\chi^2$ defined in \eqref{eq:chi2},
leaving of course unchanged the measured points.
This, more or less (resolution losses under investigation),
corresponds to positioning the missing hits at the intersections
between the $N'$-hit fit track and the inefficient layers.

Let $M = N-N'$ be the number of missing hits,
$\mathcal I = \left\{ 1,2,\ldots,N \right\}$ the set of coordinate indices,
$\hat{\mathcal I}$ the set of missing-coordinate indices,
and $\check{\mathcal I}$ the set of measured-coordinate indices.
$\mathcal I = \hat {\mathcal I} \cup \check {\mathcal I}$,
the size of $\hat{\mathcal I}$ is $M$
and the size of $\check{\mathcal I}$ is $N'$.
In order to minimize the $\chi^2$ of \eqref{eq:chi2},
we must solve the $M$-equation system:
\begin{align}
  \label{eq:minchi2}
  \frac {\partial \chi^2} {\partial x_{\hat \jmath}} =& \sum_{i=1}^{N_f}
  S_{i\hat \jmath}
  \left( \sum_{k \in \mathcal I} S_{ik} x_k+ h_i \right) = 0
  & \forall & \hat \jmath \in \hat{\mathcal I}
\end{align}
where $\hat \jmath$ is the index of missing coordinates.

Now, let us split
the $\vec x$ components in two groups: one with 
index $\hat k$ representing the missing values, the other with
index $\check k$ representing the measured coordinates.
Isolating the missing values on the left side,
system \eqref{eq:minchi2} becomes: 
\begin{align}
  \label{eq:minchi2_ext}
  \sum_{i=1}^{N_f} \sum_{\hat k \in \hat{\mathcal I}}
    S_{i\hat \jmath} S_{i\hat k} x_{\hat k} =
  & -\sum_{i=1}^{N_f} S_{i\hat \jmath}h_i
    -\sum_{i=1}^{N_f} \sum_{\check k \in \check{\mathcal I}}
    S_{i\hat \jmath} S_{i\check k} x_{\check k}
  & \forall & \hat \jmath \in \hat{\mathcal I}
\end{align}
where the right side can be computed from the measured values.

By \eqref{eq:minchi2_ext},
the problem is translated into the linear system:
\begin{align}
  \label{eq:syst}
  C \; \hat{\vec x} = \vec t
\end{align}
where
$\hat{\vec x} \equiv \left( \hat x_1, \ldots \hat x_M \right) = 
 \left(x_{\hat k_1}, \ldots, x_{\hat k_M} \right) $
is the projection of $\vec x$ onto the subspace of the missing coordinates,
$C$ is a square symmetrical matrix of dimensions $M \times M$,
and $\vec t$ is a constant vector term of dimension $M$.
The components of $C$ and $\vec t$ are evaluated from \eqref{eq:minchi2_ext}:
\begin{subequations}
  \label{eq:CT}
  \begin{align}
    \label{eq:C}
    C_{j n} = & \sum_{i=1}^{N_f} S_{i\hat k_j} S_{i\hat k_n} & j,n \in &
    \{ 1,\ldots, M \}\\
    \label{eq:T}
    t_{j } = & -\sum_{i=1}^{N_f} S_{i\hat k_j}h_i
    -\sum_{i=1}^{N_f} S_{i\hat k_j}  \sum_{\check k \in \check{\mathcal
        I}} S_{i\check k} x_{\check k}& j \in & \{1, \ldots, M \} 
  \end{align}
\end{subequations}

Finally, the missing coordinates are obtained by:
\begin{equation}
  \label{eq:solution}
  \hat{\vec x} = C^{-1} \, \vec t
\end{equation}

\section{Estimating the number of arithmetical operations}
\label{sec:extimate}

In order to figure out how the procedure could be implemented
in a FPGA chip, it can be useful to estimate the number
of products $N_\times$ and the number of sums $N_+$
at different stages of the algorithm.

Evaluation of the $N_p$ parameters in \eqref{eq:fit} requires:
\begin{subequations}
  \begin{align}
    N_\times =& N_p N \\
    N_+ =& N_p N
  \end{align}
\end{subequations}

Evaluation of the $\chi^2$ in \eqref{eq:chi2} requires:
\begin{subequations}
\label{eq:chi2_ncalc}
  \begin{align}
    N_\times =& N_f (N+1)\\
    N_+ =& N_f N + (N_f-1) = N_f (N+1) - 1
  \end{align}
\end{subequations}


Evaluation of the $M (M+1) / 2$ independent elements
of the symmetrical $C$ matrix in \eqref{eq:C} requires:
\begin{subequations}
  \begin{align}
    N_\times =& \frac{M (M+1)}{2} \, N_f \\
    N_+ =& \frac{M (M+1)}{2} \, (N_f-1)
  \end{align}
\end{subequations}

These elements do not depend on the measured hits
${\vec x}$, thus the $C^{-1}$ elements could be
pre-calculated and stored once for all in memory.
Taking into account all possible combinations of $M$
missing coordinates, the total number of constants
to be stored \emph{per sector} is:
\begin{equation}
N_C = \binom{N}{M} \frac {M (M+1)} 2 \label{eq:NC}
\end{equation}

Evaluation of the $M$ elements of $\vec t$ in \eqref{eq:T}
requires:
\begin{subequations}
  \begin{align}
    N_\times =& M (N_f + N_f (N'+1)) = M N_f (N' + 2)\\
    N_+ =& M ((N_f - 1) + (N_f N' - 1)) = M (N_f (N'+1) -1)
  \end{align}
\end{subequations}

The values of the first sum in \eqref{eq:T}
do not depend on the measured hits, but only
on the missing-coordinate index $\hat \jmath$,
and could be pre-calculated and stored once for all in memory.
Taking into account all possible missing coordinates,
the total number of constants
to be stored \emph{per sector} is:
\begin{equation}
  N_t = N
\end{equation}

Correspondingly, the number of arithmetical operations
would reduce to:
\begin{subequations}
  \begin{align}
    N_\times =& M N_f( N'+1)\\
    N_+ =& M N_f N'
  \end{align}
\end{subequations}

The most intensive calculations in equations \eqref{eq:CT} involve the product of two S matrix.
This product does not depend on the measured hits.  It can be pre-calculated as:
\begin{align}
  \label{eq:SS}
  SS_{jn} = & \sum_{i=1}^{N_f} S_{ij}  S_{in}   & j,n \in \{1, \ldots, N \}   &
\end{align}
For elements that satisfy $ j,n \in \{ 1,\ldots, M \} $ this is exactly the $C_{j n}$ matrix of equation \eqref{eq:C}.
Most importantly, equation \eqref{eq:T} reduces to:
\begin{align}
  \label{eq:T2}
  t_{j } = & -\sum_{i=1}^{N_f} S_{i\hat k_j}h_i -  \sum_{\check k \in \check{\mathcal
        I}} SS_{\hat k_j\check k} x_{\check k} & j \in \{1, \ldots, M \} &
\end{align}
The number of constants to be stored \emph{per sector} corresponds to the elements of the symmetrical SS matrix of equation \eqref{eq:SS} :
\begin{equation}
  N_{SS} = N(N-1)/2
\end{equation}
Correspondingly, the number of arithmetical operations
would reduce to:
\begin{subequations}
  \begin{align}
    N_\times =& 2 M N' \\
    N_+ =& 2 M N'
  \end{align}
\end{subequations}
We still have the option to pre-calculate the first term of \eqref{eq:T2}. This would reduce $N_\times $ to $ M N'$, but without saving on $N_+$. It would be worthwhile if we can do additions at a faster rate than multiplications.

In order to calculate the missing hits of equation \eqref{eq:solution} we can use Cramer's rule~\cite{Cramer} that requires the calculation of $M+1$ determinants of $M{\rm x}M$ matrixes. Thus the number of operations needed is:
\begin{align}
  N_/ =& 1 \\
  N_\times =& (M+1) (M-1) M! + M \\
  N_+ =& (M+1) (M! -1) 
\end{align}
where 1 division is needed to take the reciprocal of the determinant of the $C_{j n}$ matrix of equation \eqref{eq:C}.
It should be possible to further reduce the number of calculations, considering that several multiplications needed for the $M+1$ determinant calculations are duplicated. Further optimization could take advantage of optimized algorithms for determinant calculation that exist in literature.

Finally, table \ref{tab:numbers} summarizes the number of arithmetical
operations, 
as well as the number of constant values to be stored for each sector,
for different choices of pre-calculations in the current configuration
($N = 14, N_p = 5$) and for the several cases of missing coordinates ($M=1,2,\ldots$).

\begin{table}[htb]
  \centering
  \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
    \cline{4-9}
    \multicolumn{3}{c|}{ }&\multicolumn{3}{|c|}{operations}&\multicolumn{3}{|c|}{stored constants}\\
    \hline
    &&\textbf{Task} & $N_/$ & $N_\times$ & $N_+$ & $N_C$ & $N_t$ & FC \\
    \hline\hline
    &\multirow{2}{*}{14-coord. fit}&Parameters & 0 & 70  & 70 &- &- & 75\\
    &&$\chi^2$ & 0 & 135 & 208 & -& -& 135 \\
    \hline \hline

    \multirow{6}{*}{$M=1$} & \multirow{2}{*}{No Pre-Calc}& C & 0 & 9 & 8& 0& 0& - \\
    && T & 0 & 135 & 125 & 0 & 0 & - \\
    \cline{2-9}
    &\multirow{2}{*}{Pre-Calc}& C & 0 & 0 & 0 & 14 & - & - \\
    && T & 0 & 126 & 117 & - & 14 &-\\
    \cline{2-9}
    &\multirow{2}{*}{Pre-Calc SS}& Cramer & 1 & 1 & 0 & 105 & - & - \\
    && T & 0 & 26 & 26 & - & - &-\\
    \hline \hline

    \multirow{6}{*}{$M=2$} & \multirow{2}{*}{No Pre-Calc}& C & 0 & 27 & 24& 0& 0& - \\
    && T & 0 & 252 & 253 & 0 & 0 & - \\
    \cline{2-9}
    &\multirow{2}{*}{Pre-Calc}& C & 0 & 0 & 0 & 273 & - & - \\
    && T & 0 & 234 & 216 & - & 14 &-\\
    \cline{2-9}
    &\multirow{2}{*}{Pre-Calc SS}& Cramer & 1 & 8 & 3 & 105 & - & - \\
    && T & 0 & 48 & 48 & - & - &-\\
    \hline \hline

    \multirow{6}{*}{$M=3$} & \multirow{2}{*}{No Pre-Calc}& C & 0 & 54 & 48& 0& 0& - \\
    && T & 0 & 351 & 321 & 0 & 0 & - \\
    \cline{2-9}
    &\multirow{2}{*}{Pre-Calc}& C & 0 & 0 & 0 & 2184 & - & - \\
    && T & 0 & 324 & 297 & - & 14 &-\\
    \cline{2-9}
    &\multirow{2}{*}{Pre-Calc SS}& Cramer & 1 & 51 & 20 & 105 & - & - \\
    && T & 0 & 66 & 66 & - & - &-\\
    \hline \hline

    \multirow{6}{*}{$M=4$} & \multirow{2}{*}{No Pre-Calc}& C & 0 & 90 & 80& 0& 0& - \\
    && T & 0 & 432 & 392 & 0 & 0 & - \\
    \cline{2-9}
    &\multirow{2}{*}{Pre-Calc}& C & 0 & 0 & 0 & 10010 & - & - \\
    && T & 0 & 396 & 360 & - & 14 &-\\
    \cline{2-9}
    &\multirow{2}{*}{Pre-Calc SS}& Cramer & 1 & 364 & 115 & 105 & - & - \\
    && T & 0 & 80 & 80 & - & - &-\\
    \hline
  \end{tabular}
  \caption{Number of arithmetical operations and number of stored
    constants for several computational  tasks in different conditions
  of missing coordinates and pre-calculated constants.
  In the ``No Pre-Calc'' case, the numbers $N_\times$ and $N_+$ refer to the
  calculations of elements of $C$ matrix and do not include the operations to invert it.
  In the ``Pre-Calc'' case, $N_C$ is the number of stored elements 
  of all possible $C^{-1}$ matrices \eqref{eq:NC}. 
  In the ``Pre-Calc SS'' case, $N_C$ is the number of stored elements 
  of the $SS$ matrix of equation \eqref{eq:SS},
  which are the same for all M values.
  The numbers $N_/$, $N_\times$ and $N_+$ refer to the
  calculations needed to solve the equations \eqref{eq:syst} using Cramer's rule.}
   \label{tab:numbers}
\end{table}

The additional constants to be stored for the ``Pre-Calc SS'' case is 105. It represent a moderate increase with respect to the 210 FC constants.
We observe that using the ``Pre-Calc SS'' option the number of calculations up to $M=3$ becomes manageable. It is lower than those needed to calculate a $\chi^2$.

\clearpage
\newpage
\section{Recycling calculations within a road}
\label{sec:recycle}

The Fast Tracker processor will use the linear fit to fit candidate tracks within a road found by the Associative Memory~\cite{FTK-IEEE-1}.
In this framework, for each road all possible combinations of hits will be fitted.
For a road involving N layers that have $n_j$ hits in the j-th layer with $j \in \{1, \ldots, N \}$, the number of combinations of hits to fit will be:
\begin{equation}
    N_{fit} = \prod_{j=1}^{N_l} n_j 
\end{equation}
where $N_l$ is the number of layers also defined as $N_l = N - N_{pixels}$.  
It is clear that, when multiples fits within a road are needed, the scalar products of equations \eqref{eq:fit} and \eqref{eq:chi2} will repeat multiple times the product of the same hits with the same matrix elements.
Two strategies are proposed to reduce the number of calculations needed to perform all the fits.
In the following, we refer only the calculation of the $\chi^2$ because the track parameters will be evaluated only if the found $\chi^2$ is below threshold.
The first strategy calculates the product of the $S_{ij}$ matrix, see eq. \eqref{eq:chi2}, with every hit at the beginning of the road process. Thus reducing the $\chi^2$ calculation for each fit to a certain number of additions and only $N_f$ multiplications needed to square each track constraint. This strategy, needs the theoretical minimum number of multiplications. While it looks very promising, some further thought is needed to understand how to keep under control the time needed for the additions\footnote{Here I'm assuming that there is not much saving by reducing only the number of multiplications, if the hardware is able to perform additions and multiplications at a similar rate as it is true for DSP blocks in FPGAs.}.


The second strategy takes advantage of the fact that different combinations share a fraction of the hits.
For this reason, pieces of the scalar products in equation~\eqref{eq:chi2} calculated for one combination can be reused for the next combination(s).
With this approash, the first step of the road fitting algorithm will sort the layers of the road to be fit by number of hits. The layers with less hits will become the first layers, while the most populated layers will become the last.
In the follow we assume that layers are sorted.
The combinations of hits will be fit sequentially. The first combination will be identified by 
\begin{align}
k_j=&1 & \forall j \in \{1\, \ldots\, N_l\}
\end{align}
where $k_j$ is the index referring to the $k$-th hit in the $j$-th sorted layer.
For the first combination the algorithm will calculate the full $\chi^2$ of equation~\eqref{eq:chi2}. The results of all partial sums will be stored in a memory. We need $N_f$ memories (one for each constraint), with each memory being N locations deep. The $N_f \times N$ partial sums, which are summed up to the $n$-th coordinate, are defined by:
\begin{equation}
  \label{eq:partial_c}
  c_{in} =  \left( \sum_{j=1}^n S_{ij} \, x_j \right) + h_i
\end{equation}

At this point the algorithm proceeds to loop over all combinations of hits in order to calculate the $\chi^2$ for all of them.
The loop will start incrementing the $k_j$ index for $j=N_l$, when ever $k_j>n_j$ it will overflows.
Thus is will sets $k_j=1$ and it will increment $k_{j-1}$ until all combinations will be scanned.
For a given combination, lets call $m$ the incremented and non overflowed layer. For this combination the $\chi^2$ can be calculated as follows:
\begin{equation}
  \label{eq:partial_chi2}
  \chi^2 = \sum_{i=1}^{N_f} \left[ \left( \sum_{j=m}^N S_{ij} \, x_j \right) + h_i + c_{i (m-1)}\right]^2
\end{equation}
Evaluation of the $\chi^2$ in~\eqref{eq:partial_chi2} requires:
\begin{subequations}
  \begin{align}
    N_\times =& N_f (N-m+2)\\
    N_+ =& N_f (N-m+2) + (N_f-1) = N_f (N-m+3) - 1
  \end{align}
\end{subequations}
When $m$ is close to $N$ (e.g. $m=N$ or $m=N-1$) the number of needed operation is much lower than those of equations~\eqref{eq:chi2_ncalc}. 

What is the average of $N-m$ during the loop over all hit combinations?
Neglecting the fact that pixel layers correspond to two coordinates, it can be calculated as
\begin{equation}
  \label{eq:partial_chi2}
  <N-m> = \frac { \sum_{m=1}^{N_l} \left[ (N-m)*\prod_{j=m}^N n_j \right] } {\prod_{j=1}^N n_j}
\end{equation}
We can estimate this number for a case in which N=14, $n_j=1 \, \ \, j \in \{1\, \ldots\, 7\}$ and $n_j=2 \ \, \,  j \in \{8\, \ldots\, 14\}$.
In other words half of the coordinates have two hits and the other half of them have one hit.\footnote{For simplicity we assume that the pixel layers are among those with single hits.}
This example has a total of 64 combinations, with $<N-m> = N - 1.875$. 
With this approach the number of calculations can be greatly reduced. 
The actual saving depends on the typical occupancy of roads.

Most of this information is also described in slides 7 to 23 of this talk~\cite{FTK_fits}.

%%\section{Pre-selection of majority recovery fits}
%%\label{sec:majority_recovery}

%%\section{Estimate of the total number of needed calculations for a given road}
%%\label{sec:road_total}

% As baseline for the next numbers we can introduce that a linear fit
% needs of: $N$ products and $N+1$ sums, while a $\chi^2$ needs of:
% $(N+1)\times M$ products and $(N+1)\times(M+1)$ sums. Using the
% definitions in \eqref{eq:CT} is possible to extract that:
% \begin{itemize}
% \item each $\hat C$ element needs of $M$ products and $M$ sums;
  
% \item each $\vec T$ element needs of $M\times (N-G+1)$ products and
%   $M\times(N-G+M)+1$ sums;
% \end{itemize}
% considering that the number of $\hat C$ components is $G\times
% (G+1)/2$, because is a symmetric matrix, and the components in $\vec
% T$ are $G$ a summary of the relations to extract the total numbers is
% in Table \ref{tab:numbers}.




% In a realistic scenario where $N=14$, $M=9$, and $G=1,2,3$ the number
% of products and sums using the relations in 
% is listed in Tab.~\ref{tab:numbers}, to these number are also to be
% added the number of products and sums to 
% solve \eqref{eq:solution}. If to evaluate $\left| \hat C \right|$ for
% the matrix inversion we assume to use the sum of the permuted products
% of all matrix elements, and then we solve the scalar products for each
% missing coordinate the number of sums and products are given by
% \begin{subequations}
%   \begin{align}
%     N(\mathrm{sums}) = & G\times(G+1) \\
%     N(\mathrm{products}) = & G!\times G +G^2+1
%   \end{align}
% \end{subequations}
% this is equivalent to 28 products and 12 sums if $G=3$.

\bibliographystyle{unsrturl}
\bibliography{ftk}

\end{document}
