/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

///===================================================
/// TrigJpsiRootAnalysis class
///---------------------------------------------------
/// B-trigger analysis
///
/// Author: Daniel Scheirich <scheiric@cern.ch>
/// Part of TriggerJpsiAnalysis
///===================================================

#include <sstream>
#include "TrigJpsiRootAnalysis.h"
#include "TMath.h"
#include "TGraphAsymmErrors.h"
#include "TLatex.h"
#include "AtlasLabels.C"

///===================================================
void TrigJpsiRootAnalysis::analyzeJpsi(std::string settings, std::string cutStr) {
  Log log("TrigJpsiRootAnalysis::analyzeJpsi", ol());

  log.info("Settings: " + settings);
  log.info("cuts:     " + cutStr);

  // create selection algorithm
  CutsJpsi cuts(ol(), cutStr);

  std::string trackCollName = "UsedTracks";
  getValue(settings, "TrackCollName=",trackCollName);
  std::string muonCollName = "Muons";
  getValue(settings, "MuonCollName=",muonCollName);

  log.info("TrackCollName="+trackCollName);
  log.info("MuonCollName="+muonCollName);


  //histograms
  importHistFromFile("histograms_analyzeJpsi.config");

  setHistVar( "jpsi"         , &m_jpsi          );
  setHistVar( "jpsi_trk"     , &m_jpsi_trk      );
  setHistVar( "jpsi_fex"     , &m_jpsi_fex      );
  setHistVar( "jpsi_muID"    , &m_jpsi_muID     );
  setHistVar( "jpsi_chi2Prob", &m_jpsi_chi2Prob );
  setHistVar( "jpsi_dPhi"    , &m_jpsi_dPhi     );
  setHistVar( "jpsi_pt"      , &m_jpsi_pt       );
  setHistVar( "jpsi_eta"     , &m_jpsi_eta      );

  setHistVar( "trk_chi2"     , &m_trk_chi2      );
  setHistVar( "mu_eta"       , &m_mu_eta        );
  setHistVar( "mu_pt"        , &m_mu_pt         );
  setHistVar( "muMax_pt"     , &m_muMax_pt      );
  setHistVar( "muMin_pt"     , &m_muMin_pt      );
  setHistVar( "mu_e"         , &m_mu_e          );
  setHistVar( "mu_pixHits"   , &m_mu_pixHits    );
  setHistVar( "mu_sctHits"   , &m_mu_sctHits    );
  setHistVar( "mu_mdtHits"   , &m_mu_mdtHits    );

  // set pointer to the used cuts so they can be automaticaly drawn into the selected histograms
  setCutsForHist(&cuts);

  // get pointer to histograms we will need further
  TH1D* h_jpsi = getHist("jpsi");

  // invariant mass window for Jpsi
  int loBin = 1;
  int hiBin = 1;
  if(isDefined("jpsi")) hiBin = getHist("jpsi")->GetNbinsX()+1;
  getValue(settings,"massBinLo=",loBin);
  getValue(settings,"massBinHi=",hiBin);

  // create ".py" file with the list of selected events for each run. Used for AOD skimming
  bool doEventList = settings.find("DoEventList") != std::string::npos;
  ofstream* fout = NULL;
  if(doEventList) {
    fout = new ofstream("eventList.py");
    (*fout) << "## List of selected J/psi events. Generated by TrigJpsiRootAnalysis " << std::endl << std::endl;
    (*fout) << "runList   = [ ]   # list of run numbers" << std::endl;
    (*fout) << "eventList = [ ]   # list of events containing J/psi" << std::endl << std::endl;
  }

  // event info
  int oldRun = -1;
  int oldEvt = -1;

  //loop over all entries and all files
  log.info("******************************************************************");
  log.info("** BEGINNING OF THE LOOP                                        **");
  log.info("******************************************************************");

  //loop over files
  resetIterator();
  while( iterateFiles() ) {
    //load trees
    TTree* tJpsi    = loadTree("Jpsi");
    TTree* tTrig    = loadTree("TRIG");
    TTree* tTracks  = loadTree("UsedTracks");
    TTree* tMuons   = loadTree("Muons");

    log.debug("Trees loaded");

    //check that all the trees are loaded correctly
    if(tJpsi == NULL || tTracks == NULL || tMuons == NULL) {
      addCorruptedFile(currentFileName());
      continue;
    }

    //skip files with no entries
    if(tJpsi->GetEntries() == 0) {
      log.warning("No entries, skipping file");
      continue;
    }

    //prepare NtupleReader
    log.debug("Preparing NtupleReader");
    NtupleReader theReader;
    if(tTrig->GetEntries() > 0)   theReader.prepareTree("TRIG",        tTrig);
    if(tMuons->GetEntries() > 0)  theReader.prepareTree(muonCollName,  tMuons);
    if(tTracks->GetEntries() > 0) theReader.prepareTree(trackCollName, tTracks);
    log.debug("done");

    // make BCompositeParticle
    BCompositeParticle* Jpsi = new BCompositeParticle(tJpsi, "Jpsi");

    // trigger pass-through
    std::vector<std::string>* l2PassThrough = new std::vector<std::string>;
    if( settings.find("UseEFPassThrough") != std::string::npos)
      tTrig->SetBranchAddress("TRIG_EF_pass_through", &l2PassThrough);
    else
      tTrig->SetBranchAddress("TRIG_L2_pass_through", &l2PassThrough);

    //loop over entries
    int step = tJpsi->GetEntries()/20;
    for(int entry = 0; entry < (int)tJpsi->GetEntries(); ++entry) {
      if(step == 0 || entry%step == 0) log.info("   ===> Entry " + iToStr(entry));

      // load BCompositeParticles using NtupleReader
      Jpsi->GetEntry(entry);

      TriggerBag trigDecisions = theReader.getTriggers(Jpsi->runNumber, Jpsi->eventNumber, "TRIG", tTrig);
      TrackBag   tracks        = theReader.getTracks(Jpsi->runNumber, Jpsi->eventNumber, "UsedTracks", tTracks);
      MuonBag    muons         = theReader.getMuons(Jpsi->runNumber, Jpsi->eventNumber, "Muons", tMuons);

      /// level-1 jpsi and GRL =============================================================

      if( !cuts.selectTrigger(trigDecisions, l2PassThrough) ) continue;
      if( !cuts.selectGRL(Jpsi->runNumber, Jpsi->lumiBlock) ) continue;

      /// offline jpsi =============================================================

      log.debug("offline jpsi analysis");

      // J/psi selection
      if( !cuts.selectJpsi(Jpsi, tracks,  muons) ) continue;

      //fill J/psi histogram
      m_jpsi.push_back(Jpsi->VTX_mass/1000);
      m_jpsi_chi2Prob.push_back( TMath::Prob(Jpsi->VTX_chi2, Jpsi->VTX_NDF) );
      m_jpsi_dPhi.push_back( cuts.jpsiDPhi );
      m_jpsi_pt.push_back(Jpsi->VTX_pt/1000);
      m_jpsi_eta.push_back(Jpsi->getRefMom().Eta());

      //J/psi tracks
      m_trk_chi2.push_back(cuts.jpsiTrk0.chi2()/cuts.jpsiTrk0.ndf());
      m_trk_chi2.push_back(cuts.jpsiTrk1.chi2()/cuts.jpsiTrk1.ndf());

      m_mu_pt.push_back(Jpsi->getTrackMom(0).Perp());
      m_mu_pt.push_back(Jpsi->getTrackMom(1).Perp());

      m_muMax_pt.push_back(TMath::Max(Jpsi->getTrackMom(0).Perp(),Jpsi->getTrackMom(1).Perp()) );
      m_muMin_pt.push_back(TMath::Min(Jpsi->getTrackMom(0).Perp(),Jpsi->getTrackMom(1).Perp()) );

      m_mu_eta.push_back(Jpsi->getTrackMom(0).Eta() );
      m_mu_eta.push_back(Jpsi->getTrackMom(1).Eta());

      // muon energy is calculated inside CutsJpsi::selectJpsi method
      m_mu_e.push_back(cuts.E0);
      m_mu_e.push_back(cuts.E1);

      //number of hits, also retrieved in CutsJpsi::selectJpsi method
      m_mu_pixHits.push_back(cuts.mu0_pixHits);
      m_mu_pixHits.push_back(cuts.mu1_pixHits);

      m_mu_sctHits.push_back(cuts.mu0_sctHits);
      m_mu_sctHits.push_back(cuts.mu1_sctHits);

      m_mu_mdtHits.push_back(cuts.mu0_mdtHits);
      m_mu_mdtHits.push_back(cuts.mu1_mdtHits);

      /// update no. of selected jpsi's

      if(h_jpsi!=NULL &&
        Jpsi->VTX_mass > h_jpsi->GetBinLowEdge(loBin) &&
        Jpsi->VTX_mass < h_jpsi->GetBinLowEdge(hiBin))
      {
        ++m_nCandidates;
      }

      // create ".py" file with the list of selected events for each run. Used for AOD skimming
      if(doEventList) {
        // new run number
        if(Jpsi->runNumber != oldRun ) {
          //close previous fileList brace
          if(oldEvt!=-1) {
            (*fout) << " ] ]" << std::endl << std::endl;
          }

          // start new run and event list
          (*fout) << "runList   += [ \"" << Jpsi->runNumber << "\" ]" << std::endl;
          (*fout) << "eventList += [ [ ";

          // update
          oldRun = Jpsi->runNumber;
          oldEvt = -1;
        }

        if(Jpsi->eventNumber != oldEvt ) {
          if(oldEvt!=-1)
            (*fout) << ", ";

          // print event number
          (*fout) << "\"" << Jpsi->eventNumber << "\"";

          // update
          oldEvt = Jpsi->eventNumber;
        }
      }

      /// fill the histograms ========================================================

      fillAll();
    } // end of the tree loop
  } // end of the file loop
  log.info("******************************************************************");

  // close ".py" file with the list of selected events for each run. Used for AOD skimming
  if(doEventList) {
    if(oldEvt!=-1) {
      (*fout) << " ] ]" << std::endl << std::endl;
    }

    fout->close();
    delete fout;
  }

  // fitting ------------------------------
  TF1* fitFun = fitGaus("jpsi", settings);

  //drawing ------------------------------

  if(isDefined("jpsi")) {
    new TCanvas("c_jpsi","c_jpsi");

    // set histograms style
    setMarkerStyle("jpsi",20);

    // draw histogram
    drawHist(NameList("jpsi"));

    // draw fitfun
    if(fitFun!=NULL) fitFun->Draw("same");

    // indication of cuts
    int loBin;
    int hiBin;
    if(getValue(settings,"massBinLo=",loBin) && getValue(settings,"massBinHi=",hiBin)) {
      drawCuts(getHist("jpsi")->GetBinLowEdge(loBin), getHist("jpsi")->GetBinLowEdge(hiBin), "jpsi");
    }

  }

  /// other histograms
  drawMoreHist(NameList("jpsi_chi2Prob", "jpsi_dPhi", "jpsi_pt", "jpsi_eta"));

  drawMoreHist(NameList("trk_chi2", "mu_pt", "mu_eta", "mu_e", "mu_pixHits", "mu_sctHits", "mu_mdtHits"));

  if(isDefined("muMax_pt") && isDefined("muMin_pt")) {
    new TCanvas("c_muMinMax","muMinMax");

    // set hist style
    setMarkerStyle("muMax_pt", 20);
    setMarkerStyle("muMin_pt", 21);
    getHist("muMin_pt")->SetMarkerColor(kBlue);

    // draw
    drawHist(NameList("muMin_pt","muMax_pt"));

    // legend
    drawLegend(NameList("muMax_pt", "muMin_pt"), 0.55,0.5,0.9,0.3);


  }

}
///===================================================
void TrigJpsiRootAnalysis::analyzeChain(std::string chain, std::string settings, std::string cutStr) {
  Log log("TrigJpsiRootAnalysis::analyzeChain", ol());

  log.info("Settings: " + settings);
  log.info("cuts:     " + cutStr);

  // create selection algorithm
  CutsJpsi cuts(ol(), cutStr);

  std::string trackCollName = "UsedTracks";
  getValue(settings, "TrackCollName=",trackCollName);
  std::string muonCollName = "Muons";
  getValue(settings, "MuonCollName=",muonCollName);

  //histograms
  importHistFromFile("histograms_analyzeChain.config");

  // mass plots
  double prescale = 1;      // chain prescale

  setHistVar( "jpsi"            , &m_jpsi          );
  setHistVar( "jpsi_trk"        , &m_jpsi_trk      , &prescale);
  setHistVar( "jpsi_fex"        , &m_jpsi_fex      , &prescale);
  setHistVar( "jpsi_muID"       , &m_jpsi_muID     , &prescale);
  setHistVar( "jpsi_vtx"        , &m_jpsi_vtx      , &prescale);

  // pt plots
  setHistVar( "jpsiPt0"         , &m_jpsiPt[0]     );
  setHistVar( "jpsiPt_trk0"     , &m_jpsiPt_trk[0] , &prescale);
  setHistVar( "jpsiPt_fex0"     , &m_jpsiPt_fex[0] , &prescale);
  setHistVar( "jpsiPt_hypo0"    , &m_jpsiPt_hypo[0], &prescale);
  setHistVar( "jpsiPt1"         , &m_jpsiPt[1]     );
  setHistVar( "jpsiPt_trk1"     , &m_jpsiPt_trk[1] , &prescale);
  setHistVar( "jpsiPt_fex1"     , &m_jpsiPt_fex[1] , &prescale);
  setHistVar( "jpsiPt_hypo1"    , &m_jpsiPt_hypo[1], &prescale);
  setHistVar( "jpsiPt2"         , &m_jpsiPt[2]     );
  setHistVar( "jpsiPt_trk2"     , &m_jpsiPt_trk[2] , &prescale);
  setHistVar( "jpsiPt_fex2"     , &m_jpsiPt_fex[2] , &prescale);
  setHistVar( "jpsiPt_hypo2"    , &m_jpsiPt_hypo[2], &prescale);

  // eta plots
  setHistVar( "jpsiEta0"         , &m_jpsiEta[0]     );
  setHistVar( "jpsiEta_trk0"     , &m_jpsiEta_trk[0] , &prescale);
  setHistVar( "jpsiEta_fex0"     , &m_jpsiEta_fex[0] , &prescale);
  setHistVar( "jpsiEta_hypo0"    , &m_jpsiEta_hypo[0], &prescale);
  setHistVar( "jpsiEta1"         , &m_jpsiEta[1]     );
  setHistVar( "jpsiEta_trk1"     , &m_jpsiEta_trk[1] , &prescale);
  setHistVar( "jpsiEta_fex1"     , &m_jpsiEta_fex[1] , &prescale);
  setHistVar( "jpsiEta_hypo1"    , &m_jpsiEta_hypo[1], &prescale);
  setHistVar( "jpsiEta2"         , &m_jpsiEta[2]     );
  setHistVar( "jpsiEta_trk2"     , &m_jpsiEta_trk[2] , &prescale);
  setHistVar( "jpsiEta_fex2"     , &m_jpsiEta_fex[2] , &prescale);
  setHistVar( "jpsiEta_hypo2"    , &m_jpsiEta_hypo[2], &prescale);

  // muon plots
  setHistVar( "mu_eta"          , &m_mu_eta        );
  setHistVar( "mu_pt"           , &m_mu_pt         );
  setHistVar( "trigTrk_eta"     , &m_trigTrk_eta   );
  setHistVar( "trigTrk_pt"      , &m_trigTrk_pt    );

  setHistVar( "trig_chi2"       , &m_trig_chi2     );

  setHistVar( "num_muID"        , &m_num_muID      );
  setHistVar( "num_vtx"         , &m_num_vtx       );

  // check mandatory histograms
  if(!isDefined("jpsi")) {
    log.error("Histogram \"jpsi\" is mandatory. Leaving...");
    return;
  }

  //set custom histogram titles
  setTitle("jpsi", ("J/#psi: "+chain).c_str());

  // set pointer to the used cuts so they can be automaticaly drawn into the selected histograms
  setCutsForHist(&cuts);

  // invariant mass range used to calculate efficiency
  int loBin = 1;
  int hiBin = getHist("jpsi")->GetNbinsX()+1;
  getValue(settings,"massBinLo=",loBin);
  getValue(settings,"massBinHi=",hiBin);

  // pointer to some histograms we will need further
  TH1D* h_jpsi      = getHist("jpsi");
  TH1D* h_num_muID = getHist("num_muID");
  TH1D* h_num_vtx   = getHist("num_vtx");

  //loop over all entries and all files
  log.info("******************************************************************");
  log.info("** BEGINNING OF THE LOOP                                        **");
  log.info("******************************************************************");

  //loop over files
  resetIterator();
  while( iterateFiles() ) {
    //load trees
    TTree* tJpsi    = loadTree("Jpsi");
    TTree* tTrig    = loadTree("TRIG");
    TTree* tTracks  = loadTree("UsedTracks");
    TTree* tMuons   = loadTree("Muons");
    TTree* tChain   = loadTree(chain);
    log.debug("Trees loaded");

    //check that all the trees are loaded correctly
    if(tJpsi == NULL || tTrig == NULL || tTracks == NULL || tMuons == NULL || tChain == NULL) {
      addCorruptedFile(currentFileName());
      continue;
    }

    //skip files with no entries
    if(tJpsi->GetEntries() == 0) {
      log.debug("No entries, skipping file");
      continue;
    }

    //prepare NtupleReader
    log.debug("Preparing NtupleReader");
    NtupleReader theReader;
    if(tTrig->GetEntries() > 0)   theReader.prepareTree("TRIG",        tTrig);
    if(tMuons->GetEntries() > 0)  theReader.prepareTree(muonCollName,  tMuons);
    if(tTracks->GetEntries() > 0) theReader.prepareTree(trackCollName, tTracks);
    log.debug("done");

    // trigger pass-through
    std::vector<std::string>* l2PassThrough = new std::vector<std::string>;
    if( settings.find("UseEFPassThrough") != std::string::npos) {
      tTrig->SetBranchAddress("TRIG_EF_pass_through", &l2PassThrough);
    }else{
      tTrig->SetBranchAddress("TRIG_L2_pass_through", &l2PassThrough);
    }

    // make BCompositeParticle & chain
    BCompositeParticle* Jpsi      = new BCompositeParticle(tJpsi, "Jpsi");
    Chain*              trigChain = new Chain(tChain, chain);

    //loop over entries
    int step = tJpsi->GetEntries()/3;
    if(tJpsi->GetEntries()<1000) step = 10000;
    for(int entry = 0; entry < (int)tJpsi->GetEntries(); ++entry) {
      if(step == 0 || (entry+1)%step == 0) log.info("   ===> Entry " + iToStr(entry));

      // load BCompositeParticles using NtupleReader
      Jpsi->GetEntry(entry);
      trigChain->GetEntry(entry);

      TriggerBag trigDecisions = theReader.getTriggers(Jpsi->runNumber, Jpsi->eventNumber, "TRIG", tTrig);
      TrackBag   tracks        = theReader.getTracks(Jpsi->runNumber, Jpsi->eventNumber, "UsedTracks", tTracks);
      MuonBag    muons         = theReader.getMuons(Jpsi->runNumber, Jpsi->eventNumber, "Muons", tMuons);

      /// level-1 jpsi =============================================================

      if( !cuts.selectTrigger(trigDecisions, l2PassThrough) ) continue;
      if( !cuts.selectGRL(Jpsi->runNumber, Jpsi->lumiBlock) ) continue;

      /// offline jpsi =============================================================

      log.debug("offline jpsi analysis");

      // J/psi selection
      if( !cuts.selectJpsi(Jpsi, tracks,  muons) ) continue;

      // get prescale
      prescale = getPrescale(chain, trigDecisions);
      if(prescale!=1) log.info("Prescale="+fToStr(prescale));

      //fill J/psi histogram
      m_jpsi.push_back(Jpsi->VTX_mass/1000);

      if(h_jpsi!=NULL &&
         Jpsi->VTX_mass/1000 > h_jpsi->GetBinLowEdge(loBin) &&
         Jpsi->VTX_mass/1000 < h_jpsi->GetBinLowEdge(hiBin))
      {
        m_jpsiPt[0].push_back(Jpsi->VTX_pt/1000);
        m_jpsiPt[1].push_back( min(Jpsi->getTrackMom(0).Perp()/1000, Jpsi->getTrackMom(1).Perp()/1000) );
        m_jpsiPt[2].push_back( max(Jpsi->getTrackMom(0).Perp()/1000, Jpsi->getTrackMom(1).Perp()/1000) );

        m_jpsiEta[0].push_back(Jpsi->getRefMom().Eta());
        m_jpsiEta[1].push_back( Jpsi->getTrackMom(0).Perp() < Jpsi->getTrackMom(1).Perp() ? Jpsi->getTrackMom(0).Eta() : Jpsi->getTrackMom(1).Eta() );
        m_jpsiEta[2].push_back( Jpsi->getTrackMom(0).Perp() > Jpsi->getTrackMom(1).Perp() ? Jpsi->getTrackMom(0).Eta() : Jpsi->getTrackMom(1).Eta() );
      }

      /// trigger ==================================================================
      log.debug("found jpsi now do trigger analysis, mass = " +fToStr(Jpsi->VTX_mass/1000));

      /// trigger tracks efficiency ================================================

      for(int j=0; j<2; ++j) {
        // fill offline tracks histograms
        m_mu_pt.push_back(Jpsi->getTrackMom(j).Perp()/1000);
        m_mu_eta.push_back(Jpsi->getTrackMom(j).Eta() );
        log.debug("muon with momentum " +fToStr(Jpsi->getTrackMom(j).Perp()));
        log.debug("muon with eta " +fToStr(Jpsi->getTrackMom(j).Eta()));
        log.debug("muon with phi " +fToStr(Jpsi->getTrackMom(j).Phi()));

        // find matching online tracks
        double minDR = 2000;
        for(int i=0; i<(int)trigChain->AllTracks_eta->size(); ++i) {
          //matching to muons
          double dEta = fabs( Jpsi->getTrackMom(j).Eta() - trigChain->AllTracks_eta->at(i) );
          double dPhi = fabs( Jpsi->getTrackMom(j).Phi() - trigChain->AllTracks_phi->at(i) );
          if(dPhi > TMath::Pi()) dPhi = 2*TMath::Pi() - dPhi;
          double dR = fabs(dEta*dEta + dPhi*dPhi);
          if(dR<minDR) minDR = dR;
          log.debug("tr track with momentum " +fToStr(trigChain->AllTracks_pt->at(i)));
          log.debug("tr track with eta " +fToStr(trigChain->AllTracks_eta->at(i)));
          log.debug("tr track with phi " +fToStr(trigChain->AllTracks_phi->at(i)));
          log.debug("tr track dR " +fToStr(dR));
        }

        // matching online track was found
        if( cuts.cut_trigTrkDR > minDR ) {
          m_trigTrk_pt.push_back(Jpsi->getTrackMom(j).Perp()/1000);
          m_trigTrk_eta.push_back(Jpsi->getTrackMom(j).Eta());
        }
      }

      /// matched trigger objects ==================================================

      log.debug("Matched tracks " + iToStr(trigChain->MatchedTracks_valid->size()));

      //Trigger tracking
      if (trigChain->MatchedTracks_valid->size() >1) {
        if(trigChain->MatchedTracks_valid->at(0) && trigChain->MatchedTracks_valid->at(1) ) {
          m_jpsi_trk.push_back(Jpsi->VTX_mass/1000);

          if(h_jpsi!=NULL &&
             Jpsi->VTX_mass/1000 > h_jpsi->GetBinLowEdge(loBin) &&
             Jpsi->VTX_mass/1000 < h_jpsi->GetBinLowEdge(hiBin))
          {
            m_jpsiPt_trk[0].push_back(Jpsi->VTX_pt/1000);
            m_jpsiPt_trk[1].push_back( min(Jpsi->getTrackMom(0).Perp()/1000, Jpsi->getTrackMom(1).Perp()/1000) );
            m_jpsiPt_trk[2].push_back( max(Jpsi->getTrackMom(0).Perp()/1000, Jpsi->getTrackMom(1).Perp()/1000) );

            m_jpsiEta_trk[0].push_back(Jpsi->getRefMom().Eta());
            m_jpsiEta_trk[1].push_back( Jpsi->getTrackMom(0).Perp() < Jpsi->getTrackMom(1).Perp() ? Jpsi->getTrackMom(0).Eta() : Jpsi->getTrackMom(1).Eta() );
            m_jpsiEta_trk[2].push_back( Jpsi->getTrackMom(0).Perp() > Jpsi->getTrackMom(1).Perp() ? Jpsi->getTrackMom(0).Eta() : Jpsi->getTrackMom(1).Eta() );
          }
        }
      }

      log.debug("Matched fitmass size " + iToStr(trigChain->Matched_fitMass->size()));

      if(trigChain->Matched_fitMass->size() > 0 ) {

        /// FEX
        if( cuts.selectFEX(trigChain, true) ) {

          m_jpsi_fex.push_back(Jpsi->VTX_mass/1000);

          if(h_jpsi!=NULL &&
             Jpsi->VTX_mass/1000 > h_jpsi->GetBinLowEdge(loBin) &&
             Jpsi->VTX_mass/1000 < h_jpsi->GetBinLowEdge(hiBin))
          {
            m_jpsiPt_fex[0].push_back(Jpsi->VTX_pt/1000);
            m_jpsiPt_fex[1].push_back( min(Jpsi->getTrackMom(0).Perp()/1000, Jpsi->getTrackMom(1).Perp()/1000) );
            m_jpsiPt_fex[2].push_back( max(Jpsi->getTrackMom(0).Perp()/1000, Jpsi->getTrackMom(1).Perp()/1000) );

            m_jpsiEta_fex[0].push_back(Jpsi->getRefMom().Eta());
            m_jpsiEta_fex[1].push_back( Jpsi->getTrackMom(0).Perp() < Jpsi->getTrackMom(1).Perp() ? Jpsi->getTrackMom(0).Eta() : Jpsi->getTrackMom(1).Eta() );
            m_jpsiEta_fex[2].push_back( Jpsi->getTrackMom(0).Perp() > Jpsi->getTrackMom(1).Perp() ? Jpsi->getTrackMom(0).Eta() : Jpsi->getTrackMom(1).Eta() );
          }

          /// Hypo
          if( cuts.selectHypo(trigChain, true) ) {
            m_jpsi_muID.push_back(Jpsi->VTX_mass/1000);

            if(h_jpsi!=NULL &&
               Jpsi->VTX_mass/1000 > h_jpsi->GetBinLowEdge(loBin) &&
               Jpsi->VTX_mass/1000 < h_jpsi->GetBinLowEdge(hiBin))
            {
              m_jpsiPt_hypo[0].push_back(Jpsi->VTX_pt/1000);
              m_jpsiPt_hypo[1].push_back( min(Jpsi->getTrackMom(0).Perp()/1000, Jpsi->getTrackMom(1).Perp()/1000) );
              m_jpsiPt_hypo[2].push_back( max(Jpsi->getTrackMom(0).Perp()/1000, Jpsi->getTrackMom(1).Perp()/1000) );

              m_jpsiEta_hypo[0].push_back(Jpsi->getRefMom().Eta());
              m_jpsiEta_hypo[1].push_back( Jpsi->getTrackMom(0).Perp() < Jpsi->getTrackMom(1).Perp() ? Jpsi->getTrackMom(0).Eta() : Jpsi->getTrackMom(1).Eta() );
              m_jpsiEta_hypo[2].push_back( Jpsi->getTrackMom(0).Perp() > Jpsi->getTrackMom(1).Perp() ? Jpsi->getTrackMom(0).Eta() : Jpsi->getTrackMom(1).Eta() );
            }
          }

          // If requested, perform efficiency scan using different number-of-hits cut
          if(h_num_muID != NULL && h_jpsi!=NULL && cuts.cut_doNMuHitsScan.enabled &&
             Jpsi->VTX_mass/1000 >= h_jpsi->GetBinLowEdge(loBin) &&
             Jpsi->VTX_mass/1000 < h_jpsi->GetBinLowEdge(hiBin))
          {
            log.debug("NHits efficiency scan");

            for(int nHits=0; nHits < h_num_muID->GetNbinsX(); ++nHits) {
              if( cuts.selectHypo( trigChain, true, -1, nHits ) ) {
                m_num_muID.push_back(nHits);  // efficiency scan histogram
              }
            } // end of loop over nHist
          }  // end of efficiency scan for different number-of-hits cuts

          // If requested, perform efficiency scan using different chi2 cuts
          if(h_num_vtx != NULL && h_jpsi!=NULL && cuts.cut_doChi2Scan.enabled &&
             Jpsi->VTX_mass/1000 > h_jpsi->GetBinLowEdge(loBin) &&
             Jpsi->VTX_mass/1000 < h_jpsi->GetBinLowEdge(hiBin))
          {
            for(int j=1; j <= h_num_vtx->GetNbinsX() ; ++j) {
              double chi2Cut = h_num_vtx->GetBinLowEdge(j+1);

              if( cuts.selectHypo( trigChain, true, chi2Cut ) ) {
                m_num_vtx.push_back(h_num_vtx->GetBinCenter(j));    // efficiency scan histogram
              }
            } // end of loop over chi2 cuts
          } // end of efficiency scan for different vertexing chi2 cuts

        } // end of FEX
      }

      /// update no. of selected jpsi's

      if(h_jpsi!=NULL &&
         Jpsi->VTX_mass/1000 > h_jpsi->GetBinLowEdge(loBin) &&
         Jpsi->VTX_mass/1000 < h_jpsi->GetBinLowEdge(hiBin))
      {
        ++m_nCandidates;
      }

      /// fill the histograms ========================================================

      fillAll();


    } // end of the loop
  } // end of loop over files
  log.info("******************************************************************");


  // fitting ------------------------------
  TF1* fitFun = fitGaus("jpsi", settings);

  //drawing ------------------------------
  /// matched trigger object
  if(isDefined("jpsi") && isDefined("jpsi_trk")) {
    TCanvas* c = new TCanvas("c_jpsi","c_jpsi",0,0,800,600);

    // set histograms style
    setMarkerStyle("jpsi",20);
    setFillStyle("jpsi_trk",  kRed);
    setFillStyle("jpsi_fex",  kGreen);
    setFillStyle("jpsi_muID", kYellow);
    setFillStyle("jpsi_vtx",  kMagenta);

    // draw histogram
    drawHist(NameList("jpsi_trk", "jpsi_fex", "jpsi_muID", "jpsi"));

    // draw fitfun
    if(fitFun!=NULL) fitFun->Draw("same");

    // legend
    if(fitFun == NULL){
      drawLegend(NameList("jpsi", "jpsi_trk", "jpsi_fex", "jpsi_muID"), 0.55,0.9,0.9,0.7);
    }else {
      drawLegend(NameList("jpsi", "jpsi_trk", "jpsi_fex", "jpsi_muID"), 0.55,0.9,0.9,0.7,
                 std::vector<TF1*>(1,fitFun),
                 std::vector<std::string>(1,"Fit to Offline"));

      std::stringstream ss;
      ss << "#splitline{#mu = (" <<
          std::setprecision(4) << fitFun->GetParameter(1) << " #pm " << std::setprecision(1) << fitFun->GetParError(1) <<
          ") GeV}{#sigma = (" <<
          std::setprecision(2) << fitFun->GetParameter(2) << " #pm " << std::setprecision(1) << fitFun->GetParError(2) << ") GeV}";

      TLatex* lt = new TLatex(0.65, 0.63, ss.str().c_str());
      lt->SetNDC();
      lt->SetTextSize(0.035);
      lt->Draw();

    }

    // indication of cuts
    if(getValue(settings,"massBinLo=",loBin) && getValue(settings,"massBinHi=",hiBin))
      drawCuts(getHist("jpsi")->GetBinLowEdge(loBin), getHist("jpsi")->GetBinLowEdge(hiBin), "jpsi");

    // draw ATLAS Label
//     ATLASLabel(0.2,0.85,true,kBlack);
//     myText(0.2,0.85,kBlack,"To be approved");
//     myText(0.2,0.78,kBlack,"16.2 nb^{-1}");

    c->RedrawAxis();

    //calculate efficiency
    double denom = 0;
    std::vector<double> num;
    std::vector<double> eff;
    if( getEfficiencies( num, denom, eff, NameList("jpsi_trk","jpsi_fex","jpsi_muID","jpsi_vtx").names, "jpsi", loBin, hiBin) ) {

      log.info("No of J/psi                 : " + fToStr(denom));
      log.info("No of J/psi after Tracking  : " + fToStr(num.at(0)));
      log.info("No of J/psi after FEX       : " + fToStr(num.at(1)));
      log.info("No of J/psi after Hypo.     : " + fToStr(num.at(2)));
//       log.info("No of J/psi after vertexing : " + fToStr(num.at(3)));

      log.info("Efficiency of Tracking  : " + fToStr(eff.at(0)));
      log.info("Efficiency of FEX       : " + fToStr(eff.at(1)));
      log.info("Efficiency of Hypo.     : " + fToStr(eff.at(2)));
//       log.info("Efficiency of vertexing : " + fToStr(eff.at(3)));

    }
  }


  for(int i=0; i<3; ++i) {
    if(isDefined("jpsiPt"+iToStr(i))) {
      TCanvas* c = new TCanvas(("c_jpsiPt"+iToStr(i)).c_str(),("c_jpsiPt"+iToStr(i)).c_str(),0,0,800,600);

      // set histograms style
      setMarkerStyle("jpsiPt"+iToStr(i),20);
      setFillStyle("jpsiPt_trk"+iToStr(i),  kRed);
      setFillStyle("jpsiPt_fex"+iToStr(i),  kGreen);
      setFillStyle("jpsiPt_hypo"+iToStr(i), kYellow);

      // draw histogram
      drawHist(NameList( "jpsiPt_trk"+iToStr(i),
                         "jpsiPt_fex"+iToStr(i),
                         "jpsiPt_hypo"+iToStr(i),
                         "jpsiPt"+iToStr(i)));

      // legend
      drawLegend(NameList("jpsiPt_trk"+iToStr(i),
                          "jpsiPt_fex"+iToStr(i),
                          "jpsiPt_hypo"+iToStr(i),
                          "jpsiPt"+iToStr(i)), 0.55,0.9,0.9,0.7);

      c->RedrawAxis();

      // efficiency
      new TCanvas(("c2_jpsiPt"+iToStr(i)).c_str(),("c2_jpsiPt"+iToStr(i)).c_str(),0,0,800,600);

      TLegend* leg = new TLegend( 0.55,0.4,0.9,0.2);

      bool first = true;
      //trk
      if(isDefined("jpsiPt_trk"+iToStr(i))) {
        TGraphAsymmErrors* eff = new TGraphAsymmErrors(getHist("jpsiPt_trk"+iToStr(i)), getHist("jpsiPt"+iToStr(i)));
        eff->SetTitle(getHist("jpsiPt"+iToStr(i))->GetTitle());
        eff->GetXaxis()->SetTitle(getHist("jpsiPt"+iToStr(i))->GetXaxis()->GetTitle());
        eff->GetYaxis()->SetTitle("Efficiency");
        eff->SetMarkerStyle(20);
        eff->SetMarkerColor(kRed-2);

        if(first) {
          eff->Draw("ap");
          first = false;
        }else{
          eff->Draw("p");
        }

        leg->AddEntry(eff, getHistInfo("jpsiPt_trk"+iToStr(i))->legend.c_str(), "p");
      }

      //fex
      if(isDefined("jpsiPt_fex"+iToStr(i))) {
        TGraphAsymmErrors* eff = new TGraphAsymmErrors(getHist("jpsiPt_fex"+iToStr(i)), getHist("jpsiPt"+iToStr(i)));
        eff->SetTitle(getHist("jpsiPt"+iToStr(i))->GetTitle());
        eff->GetXaxis()->SetTitle(getHist("jpsiPt"+iToStr(i))->GetXaxis()->GetTitle());
        eff->GetYaxis()->SetTitle("Efficiency");
        eff->SetMarkerStyle(21);
        eff->SetMarkerColor(kGreen-2);

        if(first) {
          eff->Draw("ap");
          first = false;
        }else{
          eff->Draw("p");
        }
        leg->AddEntry(eff, getHistInfo("jpsiPt_fex"+iToStr(i))->legend.c_str(), "p");
      }

      //hypo
      if(isDefined("jpsiPt_hypo"+iToStr(i))) {
        TGraphAsymmErrors* eff = new TGraphAsymmErrors(getHist("jpsiPt_hypo"+iToStr(i)), getHist("jpsiPt"+iToStr(i)));
        eff->SetTitle(getHist("jpsiPt"+iToStr(i))->GetTitle());
        eff->GetXaxis()->SetTitle(getHist("jpsiPt"+iToStr(i))->GetXaxis()->GetTitle());
        eff->GetYaxis()->SetTitle("Efficiency");
        eff->SetMarkerStyle(22);
        eff->SetMarkerColor(kYellow-2);

        if(first) {
          eff->Draw("ap");
          first = false;
        }else{
          eff->Draw("p");
        }
        leg->AddEntry(eff, getHistInfo("jpsiPt_hypo"+iToStr(i))->legend.c_str(), "p");
      }

      // legend
      leg->SetFillColor(kWhite);
      leg->SetBorderSize(0);
      leg->SetTextSize(0.04);
      leg->Draw("same");

    }
  }

  for(int i=0; i<3; ++i) {
    if(isDefined("jpsiEta"+iToStr(i))) {
      TCanvas* c = new TCanvas(("c_jpsiEta"+iToStr(i)).c_str(),("c_jpsiEta"+iToStr(i)).c_str(),0,0,800,600);

      // set histograms style
      setMarkerStyle("jpsiEta"+iToStr(i),20);
      setFillStyle("jpsiEta_trk"+iToStr(i),  kRed);
      setFillStyle("jpsiEta_fex"+iToStr(i),  kGreen);
      setFillStyle("jpsiEta_hypo"+iToStr(i), kYellow);

      // draw histogram
      drawHist(NameList( "jpsiEta_trk"+iToStr(i),
               "jpsiEta_fex"+iToStr(i),
               "jpsiEta_hypo"+iToStr(i),
               "jpsiEta"+iToStr(i)));

      // legend
      drawLegend(NameList("jpsiEta_trk"+iToStr(i),
                 "jpsiEta_fex"+iToStr(i),
                 "jpsiEta_hypo"+iToStr(i),
                 "jpsiEta"+iToStr(i)), 0.55,0.9,0.9,0.7);

      c->RedrawAxis();

            // efficiency
      new TCanvas(("c2_jpsiEta"+iToStr(i)).c_str(),("c2_jpsiEta"+iToStr(i)).c_str(),0,0,800,600);

      TLegend* leg = new TLegend( 0.55,0.4,0.9,0.2);

      bool first = true;
      //trk
      if(isDefined("jpsiEta_trk"+iToStr(i))) {
        TGraphAsymmErrors* eff = new TGraphAsymmErrors(getHist("jpsiEta_trk"+iToStr(i)), getHist("jpsiEta"+iToStr(i)));
        eff->SetTitle(getHist("jpsiEta"+iToStr(i))->GetTitle());
        eff->GetXaxis()->SetTitle(getHist("jpsiEta"+iToStr(i))->GetXaxis()->GetTitle());
        eff->GetYaxis()->SetTitle("Efficiency");
        eff->SetMarkerStyle(20);
        eff->SetMarkerColor(kRed-2);

        if(first) {
          eff->Draw("ap");
          first = false;
        }else{
          eff->Draw("p");
        }

        leg->AddEntry(eff, getHistInfo("jpsiEta_trk"+iToStr(i))->legend.c_str(), "p");
      }

      //fex
      if(isDefined("jpsiEta_fex"+iToStr(i))) {
        TGraphAsymmErrors* eff = new TGraphAsymmErrors(getHist("jpsiEta_fex"+iToStr(i)), getHist("jpsiEta"+iToStr(i)));
        eff->SetTitle(getHist("jpsiEta"+iToStr(i))->GetTitle());
        eff->GetXaxis()->SetTitle(getHist("jpsiEta"+iToStr(i))->GetXaxis()->GetTitle());
        eff->GetYaxis()->SetTitle("Efficiency");
        eff->SetMarkerStyle(21);
        eff->SetMarkerColor(kGreen-2);

        if(first) {
          eff->Draw("ap");
          first = false;
        }else{
          eff->Draw("p");
        }
        leg->AddEntry(eff, getHistInfo("jpsiEta_fex"+iToStr(i))->legend.c_str(), "p");
      }

      //hypo
      if(isDefined("jpsiEta_hypo"+iToStr(i))) {
        TGraphAsymmErrors* eff = new TGraphAsymmErrors(getHist("jpsiEta_hypo"+iToStr(i)), getHist("jpsiEta"+iToStr(i)));
        eff->SetTitle(getHist("jpsiEta"+iToStr(i))->GetTitle());
        eff->GetXaxis()->SetTitle(getHist("jpsiEta"+iToStr(i))->GetXaxis()->GetTitle());
        eff->GetYaxis()->SetTitle("Efficiency");
        eff->SetMarkerStyle(22);
        eff->SetMarkerColor(kYellow-2);

        if(first) {
          eff->Draw("ap");
          first = false;
        }else{
          eff->Draw("p");
        }
        leg->AddEntry(eff, getHistInfo("jpsiEta_hypo"+iToStr(i))->legend.c_str(), "p");
      }

      // legend
      leg->SetFillColor(kWhite);
      leg->SetBorderSize(0);
      leg->SetTextSize(0.04);
      leg->Draw("same");


    }
  }

  /// single tracks
  // eta
  if(isDefined("mu_eta") && isDefined("trigTrk_eta")) {
    new TCanvas("c_mu_eta","c_mu_eta",0,0,800,600);
    setMarkerStyle("mu_eta", 20);
    setFillStyle("trigTrk_eta", kYellow);

    // draw histogram
    drawHist(NameList("mu_eta", "trigTrk_eta"));

    // legend
    drawLegend(NameList("mu_eta", "trigTrk_eta"), 0.53,0.9,0.9,0.77);

    // draw efficiency
    new TCanvas("c_eff_mu_eta","c_eff_mu_eta",0,0,800,600);
    TGraphAsymmErrors* eff_mu_eta = new TGraphAsymmErrors(getHist("trigTrk_eta"), getHist("mu_eta"));
    eff_mu_eta->SetTitle("Trigger Tracking Efficiency;#eta");
    eff_mu_eta->Draw("ap");
  }

  // pt
  if(isDefined("mu_pt") && isDefined("trigTrk_pt")) {
    TCanvas* c = new TCanvas("c_mu_pt","c_mu_pt",0,0,800,600);
    setMarkerStyle("mu_pt", 20);
    setFillStyle("trigTrk_pt", kYellow);

    // draw histogram
    drawHist(NameList("trigTrk_pt", "mu_pt"));

    // legend
    drawLegend(NameList("mu_pt", "trigTrk_pt"), 0.53,0.9,0.9,0.77);

    // draw ATLAS Label
//     ATLASLabel(0.2,0.85,true,kBlack);
//     myText(0.2,0.85,kBlack,"To be approved");
//     myText(0.2,0.78,kBlack,"16.2 nb^{-1}");

    c->RedrawAxis();

    // draw efficiency
    new TCanvas("c_eff_mu_pt","c_eff_mu_pt",0,0,800,600);
    TGraphAsymmErrors* eff_mu_pt = new TGraphAsymmErrors(getHist("trigTrk_pt"), getHist("mu_pt"));
    eff_mu_pt->SetMinimum(0);
    eff_mu_pt->SetMaximum(1.4);
    eff_mu_pt->SetTitle("Trigger Tracking Efficiency;#font[52]{p}_{T} [GeV]; Efficiency / 0.75 GeV");
    eff_mu_pt->Draw("ap");

    // draw ATLAS Label
//     ATLASLabel(0.2,0.85,true,kBlack);
//     myText(0.2,0.85,kBlack,"To be approved");
//     myText(0.2,0.78,kBlack,"16.2 nb^{-1}");

  }

  /// efficiency scan of muon identification
  if(isDefined("num_muID") && isDefined("jpsi_fex")) {
    new TCanvas("c_num_muID","c_num_muID",0,0,800,600);
    setFillStyle("num_muID", kYellow);

    // draw histogram
    drawHist("num_muID");

    //efficiency
    new TCanvas("c_eff_muID","c_eff_muID",0,0,800,600);

    //denominator
    TH1D* h_denom_muID = new TH1D(*getHist("num_muID"));
    for(int i=1; i<=h_denom_muID->GetNbinsX(); ++i) {
      h_denom_muID->SetBinContent(i,getHist("jpsi_fex")->Integral(loBin,hiBin-1));
    }

    TGraphAsymmErrors* eff_muID = new TGraphAsymmErrors(getHist("num_muID"), h_denom_muID);
    eff_muID->SetTitle("Muon id. efficiency w.r.t. candidates passing FEX ;No. of associated hits;Efficiency");
    eff_muID->Draw("ap");

  }

  /// efficiency scan of vertexing
  if(isDefined("num_vtx") && isDefined("jpsi_muID")) {
    new TCanvas("c_num_vtx","c_num_vtx",0,0,800,600);
    setFillStyle("num_vtx", kYellow);

    // draw histogram
    drawHist("num_vtx");

    //efficiency
    new TCanvas("c_eff_vtx","c_eff_vtx",0,0,800,600);

    //denominator
    TH1D* h_denom_vtx = new TH1D(*getHist("num_vtx"));
    for(int i=1; i<=h_denom_vtx->GetNbinsX(); ++i) {
      h_denom_vtx->SetBinContent(i,getHist("jpsi_muID")->Integral(loBin,hiBin-1));
    }

    TGraphAsymmErrors* eff_vtx = new TGraphAsymmErrors(getHist("num_vtx"), h_denom_vtx);
    eff_vtx->SetTitle("Vertexing efficiency w.r.t. cadidates after muon id.;Trigger vertexing #chi^{2} cut;Efficiency");
    eff_vtx->Draw("ap");

  }

  /// more plots
  drawMoreHist(NameList("trig_chi2"));

}
///===================================================
// void TrigJpsiRootAnalysis::compareChains(std::vector<std::string> chains, std::string settings, std::string cutStr) {
//   Log log("TrigJpsiRootAnalysis::compareChains", ol());
//
//   log.info("Settings : " + settings);
//   log.info("cuts:      " + cutStr);
//
//   // create selection algorithm
//   CutsJpsi cuts(ol(), cutStr);
//
//   std::string trackCollName = "UsedTracks";
//   getValue(settings, "TrackCollName=",trackCollName);
//   std::string muonCollName = "Muons";
//   getValue(settings, "MuonCollName=",muonCollName);
//
//   //histograms
//   importHistFromFile("histograms_compareChains.config");
//
//   setHistVar( "jpsi", &m_jpsi);
//
//   // check mandatory histograms
//   if(!isDefined("jpsi")) {
//     log.error("Histogram \"jpsi\" is mandatory. Leaving...");
//     return;
//   }
//
//   // get pointer to histograms we will need further
//   TH1D* h_jpsi = getHist("jpsi");
//
//   // invariant mass window for Jpsi
//   int loBin = 1;
//   int hiBin = getHist("jpsi")->GetNbinsX()+1;
//   getValue(settings,"massBinLo=",loBin);
//   getValue(settings,"massBinHi=",hiBin);
//
//   //create jpsi mass histogram for each chain
//   std::vector<std::vector<double>* > histVariables;
//   std::vector<std::string> histNames;
//
//   std::vector<std::string>::iterator chainsItr = chains.begin();
//   for(int i=0; chainsItr!=chains.end(); ++chainsItr, ++i) {
//
//     // create histogram veriable
//     std::vector<double>* histVariable = new std::vector<double>;
//     histVariables.push_back(histVariable);
//
//     // create histogram name
//     std::string histName = std::string("chain_")+iToStr(i);
//     histNames.push_back(histName);
//
//     if(isDefined(histName)) {
//
//       log.info(histName + " " + (*chainsItr) + " ");
//
//       // set variable pointer
//       setHistVar(histName, histVariable );
//
//       // set legend
//       HistInfo* histInfo = getHistInfo(histName);
//       histInfo->legend = *chainsItr;
//       histInfo->disp   = "f";
//
//       // set histogram style
//       setFillStyle(histName, kGreen + 2*i);
//     }
//   }
//
//   // declare trees
//   TTree *tJpsi, *tTracks, *tMuons, *tTrig;
//
//   //declare b-physics objects
//   BCompositeParticle jpsi;
//   TrackBag    tracks;
//   MuonBag     muons;
//   TriggerBag  trigDecisions;
//
//   //loop over all entries and all files
//   log.info("******************************************************************");
//   log.info("** BEGINNING OF THE LOOP                                        **");
//   log.info("******************************************************************");
//   m_nEntries = 0;
//   for(resetIterator();
//       iterateJpsi("Jpsi", &tJpsi, &jpsi,
//                   trackCollName, &tTracks, &tracks,
//                   muonCollName, &tMuons, &muons,
//                   "TRIG", &tTrig, &trigDecisions);
//       ++m_nEntries)
//   {
//
//     if(m_nEntries % 1000 == 0) log.info("   ===> Entry " + iToStr(m_nEntries));
//
//       /// level-1 jpsi =============================================================
//
//     if( !cuts.selectTrigger(trigDecisions) ) continue;
//
//       /// offline jpsi =============================================================
//
//     log.debug("offline jpsi analysis");
//
//       // J/psi selection
//     if( !cuts.selectJpsi(m_ntupleReader, jpsi, tracks,  muons) ) continue;
//
//       //fill J/psi histogram
//     m_jpsi.push_back(jpsi.refittedMass());
//
//
//       /// level-2 signatures =======================================================
//     log.debug("trigger analysis");
//
//       // loop over chains
//     std::vector<std::string>::iterator chainsItr = chains.begin();
//     std::vector<std::vector<double>* >::iterator histVariablesItr = histVariables.begin();
//     for(; chainsItr!=chains.end(); ++chainsItr, ++histVariablesItr) {
//       bool l2Trig = false;
//
//         // loop over trigger decisions
//       TriggerBag::iterator trigItr = trigDecisions.begin();
//       for(; trigItr!=trigDecisions.end(); ++trigItr) {
//         if( (*trigItr).name() == *chainsItr ) {
//           l2Trig = true;
//           break;
//         }
//       }
//
//         // fill the ntuple
//       if(l2Trig)
//         (*histVariablesItr)->push_back(jpsi.refittedMass());
//     }
//
//     /// update no. of selected jpsi's
//
//     if(h_jpsi!=NULL &&
//        jpsi.refittedMass() > h_jpsi->GetBinLowEdge(loBin) &&
//        jpsi.refittedMass() < h_jpsi->GetBinLowEdge(hiBin))
//     {
//       ++m_nCandidates;
//     }
//
//     /// fill the histograms ========================================================
//
//     fillAll();
//
//   } // end of the loop
//   log.info("******************************************************************");
//
//
//   // fitting ------------------------------
//   TF1* fitFun = fitGaus("jpsi", settings);
//
//   //drawing ------------------------------
//
//   /// trigger decision
//   if(isDefined("jpsi")) {
//     new TCanvas("c_jpsi_dec","c_jpsi_dec",0,0,800,600);
//
//     // draw
//     setMarkerStyle("jpsi",20);
//     drawHist("jpsi");
//     drawHist(histNames, "same");
//
//     if(fitFun!=NULL) fitFun->Draw("same");
//
//     // create legend
//     drawLegend(histNames, 0.55,0.5,0.9,0.3);
//
//     // indication of cuts
//     int loBin = 1;
//     int hiBin = getHist("jpsi")->GetNbinsX()+1;
//
//     if(getValue(settings,"massBinLo=",loBin) && getValue(settings,"massBinHi=",hiBin))
//       drawCuts(getHist("jpsi")->GetBinLowEdge(loBin), getHist("jpsi")->GetBinLowEdge(hiBin), "jpsi");
//
//     //calculate efficiency
//     double denom = 0;
//     std::vector<double> num;
//     std::vector<double> eff;
//     if( getEfficiencies( num, denom, eff, histNames, "jpsi", loBin, hiBin) ) {
//
//       log.info("No of J/psi: " + fToStr(denom));
//       std::vector<std::string>::iterator histNamesItr = histNames.begin();
//       std::vector<std::string>::iterator chainsItr = chains.begin();
//       std::vector<double>::iterator      numItr = num.begin();
//       std::vector<double>::iterator      effItr = eff.begin();
//       for(; histNamesItr!=histNames.end(); ++histNamesItr, ++chainsItr, ++numItr, ++effItr) {
//         log.info((*chainsItr) + ":     " + fToStr(*numItr));
//         log.info("Efficiency of " + (*chainsItr) + " : " + fToStr(*effItr));
//       }
//
//     }
//   }
//
// }
///===================================================

// void TrigJpsiRootAnalysis::analyzeRate(std::string chain,
//                                        std::string settings,
//                                        std::string cutStr)
// {
//   Log log("TrigJpsiRootAnalysis::analyzeRate", ol());
//
//   log.info("Settings: " + settings);
//   log.info("cuts:     " + cutStr);
//
//   // create selection algorithm
//   CutsJpsi cuts(ol(), cutStr);
//
//   std::string trackCollName = "UsedTracks";
//   getValue(settings, "TrackCollName=", trackCollName);
//   std::string muonCollName = "Muons";
//   getValue(settings, "MuonCollName=", muonCollName);
//
//   log.info("TrackCollName="+trackCollName);
//   log.info("MuonCollName="+muonCollName);
//
//   //histograms
//   importHistFromFile("histograms_analyzeRate.config");
//
//   setHistVar( "rate_muID", &m_rate_muID);
//   setHistVar( "rate_vtx",  &m_rate_vtx);
//
//   // get histograms pointers we will need further
//   TH1D* h_rate_muID = getHist("rate_muID");
//   TH1D* h_rate_vtx  = getHist("rate_vtx");
//
//   // declare trees
//   TTree *tChain, *tTrig;
//
//   //declare Chain object
//   Chain* trigChain = NULL;
//
//   //declare b-physics objects
//   TriggerBag  trigDecisions;
//
//   //loop over all entries and all files
//   log.info("******************************************************************");
//   log.info("** BEGINNING OF THE LOOP                                        **");
//   log.info("******************************************************************");
//   m_nEntries = 0;
//   int nLvl1 = 0;
//   for(resetIterator();
//       iterateChain("TRIG", &tTrig, &trigDecisions,
//                    (std::string("All_")+chain).c_str(), &tChain, &trigChain,
//                    false, false);
//       ++m_nEntries)
//   {
//
//     if(m_nEntries % 1000 == 0) log.info("   ===> Entry " + iToStr(m_nEntries));
//
//     /// level-1 trigger ==========================================================
//
//     if( !cuts.selectTrigger(trigDecisions) ) continue;
//     ++nLvl1;
//
//     /// level-2 trigger rate analysis ============================================
//     log.debug("level-2 trigger rate analysis");
//
//     // check if trigChain passed different number-of-hits cuts
//     if(h_rate_muID != NULL) {
//       for(int nHits=0; nHits < h_rate_muID->GetNbinsX(); ++nHits) {
//
//         if( cuts.selectHypo(trigChain, false, -1, nHits) ) m_rate_muID.push_back(nHits);
//       }
//     }
//
//     // check if trigChain passed different vertexing chi2 cuts
//     if(h_rate_vtx != NULL) {
//       for(int j=0; j < h_rate_vtx->GetNbinsX(); ++j) {
//         double chi2Cut = h_rate_vtx->GetBinLowEdge(j+1);   // scan
//
//         if( cuts.selectHypo(trigChain, false, chi2Cut) ) m_rate_vtx.push_back(h_rate_vtx->GetBinCenter(j+1));
//       }
//     }
//
//     /// fill the histograms ========================================================
//
//     fillAll();
//
//   } // end of the loop
//   log.info("******************************************************************");
//
//   //drawing ------------------------------
//
//   /// efficiency of muon Id
//   if(isDefined("rate_muID")) {
//     new TCanvas("c_rate_muID","c_rate_muID",0,0,800,600);
//     setFillStyle("rate_muID", kYellow);
//
//     // draw histogram
//     drawHist("rate_muID");
//
//     //efficiency
//     new TCanvas("c_rateFraction_muID","c_rateFraction_muID",0,0,800,600);
//
//     //denominator
//     TH1D* h_denom_muID = new TH1D(*getHist("rate_muID"));
//     for(int i=1; i<=h_denom_muID->GetNbinsX(); ++i) {
//       h_denom_muID->SetBinContent(i,m_nEntries);
//     }
//
//     TGraphAsymmErrors* rateFraction_muID = new TGraphAsymmErrors(getHist("rate_muID"), h_denom_muID);
//     rateFraction_muID->SetTitle("Fraction of input rate after muon id.;No. of associated hits;Reduction factor");
//     rateFraction_muID->SetMarkerStyle(1);
//     rateFraction_muID->SetMarkerSize(0.1);
//     rateFraction_muID->Draw("ap");
//
//   }
//
//   /// efficiency of vertexing
//   if(isDefined("rate_vtx")) {
//     new TCanvas("c_rate_vtx","c_rate_vtx",0,0,800,600);
//     setFillStyle("rate_vtx", kYellow);
//
//     // draw histogram
//     drawHist("rate_vtx");
//
//     //efficiency
//     new TCanvas("c_rateFraction_vtx","c_rateFraction_vtx",0,0,800,600);
//
//     //denominator
//     TH1D* h_denom_vtx = new TH1D(*getHist("rate_vtx"));
//     for(int i=1; i<=h_denom_vtx->GetNbinsX(); ++i) {
//       h_denom_vtx->SetBinContent(i,m_nEntries);
//     }
//
//     TGraphAsymmErrors* rateFraction_vtx = new TGraphAsymmErrors(getHist("rate_vtx"), h_denom_vtx);
//     rateFraction_vtx->SetTitle("Fraction of input rate after vertexing;Vertexing #chi^{2} cut;Reduction factor");
//     rateFraction_vtx->SetMarkerStyle(1);
//     rateFraction_vtx->SetMarkerSize(0.1);
//     rateFraction_vtx->Draw("ap");
//
//   }
//   double nAcc = 0;
//   if(isDefined("rate_muID")) {
//     nAcc = getHist("rate_muID")->GetBinContent( getHist("rate_muID")->GetBin( cuts.cut_hypoNMuHits.val+1 ) );
//   }
//
//   log.info("N events: " + iToStr(m_nEntries));
//   log.info("Accepted by "+cuts.cut_level1.val+": " + iToStr(nLvl1));
//   log.info("Accepted by "+chain+" : "+fToStr(nAcc));
//   log.info("Rejection wrt. Level-1: "+fToStr((double)nAcc/nLvl1));
//
// }
///===================================================

// void TrigJpsiRootAnalysis::analyzeRateSimple(std::string chain,
//                                              std::string settings,
//                                              std::string cutStr)
// {
//   Log log("TrigJpsiRootAnalysis::analyzeRateSimple", ol());
//
//   log.info("Settings: " + settings);
//   log.info("cuts:     " + cutStr);
//
// //   std::string trackCollName = "UsedTracks";
// //   getValue(settings, "TrackCollName=",trackCollName);
// //   std::string muonCollName = "Muons";
// //   getValue(settings, "MuonCollName=",muonCollName);
//
//   // create selection algorithm
//   CutsJpsi cuts(ol(), cutStr);
//
//
//   // declare trees
//   TTree *tTrig;
//
//   //declare b-physics objects
//   TriggerBag  trigDecisions;
//
//   // accept counter
//   int nAcc = 0;
//
//   //loop over all entries and all files
//   log.info("******************************************************************");
//   log.info("** BEGINNING OF THE LOOP                                        **");
//   log.info("******************************************************************");
//   m_nEntries = 0;
//   int nLvl1 = 0;
//   for(resetIterator();
//       iterateChain("TRIG", &tTrig, &trigDecisions);
//       ++m_nEntries)
//   {
//
//     if(m_nEntries % 1000 == 0) log.info("   ===> Entry " + iToStr(m_nEntries));
//
//     /// level-1 trigger ==========================================================
//
//     if( !cuts.selectTrigger(trigDecisions) ) continue;
//     ++nLvl1;
//
//     /// level-2 trigger rate analysis ============================================
//     log.debug("level-2 trigger rate analysis");
//
//     if( cuts.selectTrigDecision(trigDecisions, chain) ) ++nAcc;
//
//   } // end of the loop
//   log.info("******************************************************************");
//
//   // calculate rate rejection ------------------------------
//
//   log.info("N events: " + iToStr(m_nEntries));
//   log.info("Accepted by "+cuts.cut_level1.val+": " + iToStr(nLvl1));
//   log.info("Accepted by "+chain+" : "+iToStr(nAcc));
//   log.info("Rejection wrt. Level-1: "+fToStr((double)nAcc/nLvl1));
//
// }
///===================================================
// bool TrigJpsiRootAnalysis::iterateJpsi(std::string nameJpsi,   TTree** tJpsi,   BCompositeParticle* jpsi,
//                                        std::string nameTracks, TTree** tTracks, TrackBag* tracks,
//                                        std::string nameMuons,  TTree** tMuons,  MuonBag* muons,
//                                        std::string nameTrig,   TTree** tTrig,   TriggerBag* trigger,
//                                        std::string nameChain,  TTree** tChain,  Chain** trigChain)
// {
//   Log log("TrigJpsiRootAnalysis::iterateJpsi", ol());
//
//   //update current entry
//   ++m_currentEntry;
//
//   //end of file reached
//   if(m_currentEntry >= m_currentNEntries) {
//     m_currentEntry = 0;
//     m_currentNEntries = -1;
//   }
//
//   // process first entry in the file
//   if(m_currentEntry == 0) {
//     // sanity check
//     if(tJpsi == NULL) {
//       log.error("The Jpsi tree is not defined. Leaving...");
//       return false;
//     }
//     // sanity check
//     if((tTracks!=NULL && tracks==NULL) ||
//         (tMuons!=NULL  && muons==NULL) ||
//         (tTrig!=NULL   && trigger==NULL) ||
//         (tChain!=NULL  && trigChain==NULL) )
//     {
//       log.error("Wrong setup");
//       return false;
//     }
//
//     // loop over files until all the required trees are loaded
//     bool allOK = false;
//     while( iterateFiles() ) {
//       allOK = false;
//
//       // load trees
//       *tJpsi = loadTree(nameJpsi);
//       if(tTracks!=NULL) *tTracks = loadTree(nameTracks);
//       if(tMuons!=NULL)  *tMuons = loadTree(nameMuons);
//       if(tTrig!=NULL)   *tTrig = loadTree(nameTrig);
//       if(tChain!=NULL)  *tChain = loadTree(nameChain);
//
//       // check that trees were loaded correctly
//       if(*tJpsi == NULL ||
//           (tTracks!=NULL && *tTracks == NULL) ||
//           (tMuons!=NULL && *tMuons == NULL) ||
//           (tTrig!=NULL && *tTrig == NULL) ||
//           (tChain!=NULL && *tChain == NULL))
//       {
//         log.info("Some trees were not loaded correctly");
//         addCorruptedFile(currentFileName());
//         continue;
//       }
//
//       //skip files with no entries
//       if((*tJpsi)->GetEntries() == 0) {
//         log.info("No entries, skipping file");
//         continue;
//       }
//
//       //prepare NtupleReader
//       log.debug("Preparing NtupleReader");
//
//       if(tTracks!=NULL && (*tTracks)->GetEntries() > 0) m_ntupleReader.prepareTree(nameTracks, *tTracks);
//       if(tMuons!=NULL  && (*tMuons)->GetEntries() > 0)  m_ntupleReader.prepareTree(nameMuons,  *tMuons);
//       if(tTrig!=NULL   && (*tTrig)->GetEntries() > 0)   m_ntupleReader.prepareTree(nameTrig,   *tTrig);
//
//       //prepare Chain class
//       if(tChain !=NULL) *trigChain = new Chain(*tChain, nameChain);
//
//
//       // everything seems to be OK, we can use this file
//       allOK = true;
//       m_currentNEntries = (*tJpsi)->GetEntries();
//       break;
//
//     } // end of loop over files
//
//     if(!allOK) return false;
//   }
//
//   // read entries
//   if(m_currentEntry<m_currentNEntries) {
//     log.debug("Processing entry "+iToStr(m_currentEntry));
//     //load jpsi
//     *jpsi = m_ntupleReader.readParticleTree(m_currentEntry, nameJpsi,  *tJpsi );
//
//     // load other b-physics objects
//     if(tTracks!=NULL) *tracks  = m_ntupleReader.getTracks  (jpsi->runNumber(), jpsi->eventNumber(), nameTracks, *tTracks);
//     if(tMuons!=NULL)  *muons   = m_ntupleReader.getMuons   (jpsi->runNumber(), jpsi->eventNumber(), nameMuons,  *tMuons);
//     if(tTrig!=NULL)   *trigger = m_ntupleReader.getTriggers(jpsi->runNumber(), jpsi->eventNumber(), nameTrig,   *tTrig);
//
//     // load trigger chain object
//     if(tChain!=NULL)  (*trigChain)->GetEntry(m_currentEntry);
//   }
//
//   return true;
//
// }
///===================================================
bool TrigJpsiRootAnalysis::iterateChain(std::string nameTrig,
                                        TTree** tTrig,
                                        TriggerBag* trigger,
                                        std::string nameChain,
                                        TTree** tChain,
                                        Chain** trigChain,
                                        bool doAllTracks,
                                        bool doMatchedTracks)
{
  Log log("TrigJpsiRootAnalysis::iterateChain", ol());

  //update current entry
  ++m_currentEntry;

  //end of file reached
  if(m_currentEntry >= m_currentNEntries) {
    m_currentEntry = 0;
    m_currentNEntries = -1;
  }

  // process first entry in the file
  if(m_currentEntry == 0) {
    // sanity check
    if(tTrig == NULL || trigger==NULL) {
      log.error("The TRIG tree is not defined. Leaving...");
      return false;
    }
    // sanity check
    if( trigger==NULL ||
       (tChain!=NULL  && trigChain==NULL) )
    {
      log.error("Wrong setup");
      return false;
    }

    // loop over files until all the required trees are loaded
    bool allOK = false;
    while( iterateFiles() ) {
      allOK = false;

      // load trees
      *tTrig = loadTree(nameTrig);
      if(tChain!=NULL)  *tChain = loadTree(nameChain);

      // check that trees were loaded correctly
      // check that trees were loaded correctly
      if(*tTrig == NULL ||
          (tChain!=NULL && *tChain == NULL))
      {
        log.info("Some trees were not loaded correctly");
        addCorruptedFile(currentFileName());
        continue;
      }

      //skip files with no entries
      if((*tTrig)->GetEntries() == 0) {
        log.info("No entries, skipping file");
        continue;
      }

      // check that tTrig and tChain trees have the same length
      if(tChain!=NULL && (*tTrig)->GetEntries() != (*tChain)->GetEntries()) {
        log.info("(*tTrig)->GetEntries() != (*tChain)->GetEntries(), skipping file");
        continue;
      }

      //create Chain class
      if(tChain!=NULL)
        *trigChain = new Chain(*tChain, nameChain, doAllTracks, doMatchedTracks);

      // everything seems to be OK, we can use this file
      allOK = true;
      m_currentNEntries = (*tTrig)->GetEntries();
      break;

    } // end of loop over files

    if(!allOK) return false;
  }

  // read entries
  if(m_currentEntry<m_currentNEntries) {
    log.debug("Processing entry "+iToStr(m_currentEntry));

    //load Trigger decisions
    *trigger = m_ntupleReader.readTriggerTree(m_currentEntry, nameTrig,   *tTrig);

    // load trigger chain object
    if(tChain!=NULL)
      (*trigChain)->GetEntry(m_currentEntry);

  }

  return true;
}
///===================================================
TF1* TrigJpsiRootAnalysis::fitGaus(std::string name, std::string settings) {

  TF1* fitFun = NULL;

  if(isDefined(name) && settings.find("gaus")!=string::npos) {
    double fitMin = 2500;
    double fitMax = 3700;

    getValue(settings, "fitMin=", fitMin);
    getValue(settings, "fitMax=", fitMax);

    if(settings.find("gaus+pol1")!=string::npos) {
      fitFun = new TF1("fitFun","gaus(0)+pol1(3)",fitMin,fitMax);
    } else if(settings.find("gaus+const")!=string::npos) {
      fitFun = new TF1("fitFun","gaus(0)+[3]",fitMin,fitMax);
    } else {
      fitFun = new TF1("fitFun","gaus(0)",fitMin,fitMax);
    }

    fitFun->SetParameters(0.5*getHist(name)->GetEntries(), 3.1, 0.07, getHist(name)->GetEntries() / (fitMax-fitMin));
    fitFun->SetParNames("Area", "#mu", "#sigma", "p_{0}", "p_{1}");
    fitFun->SetParLimits(2,0,1000);
//     fitFun->SetParLimits(3,0,50);

    getHist(name)->Fit(fitFun,"0 R");

    fitFun->SetLineColor(kBlue+1);
  }

  return fitFun;
}
///===================================================
bool TrigJpsiRootAnalysis::getEfficiencies(std::vector<double>& num,
                                           double& denom,
                                           std::vector<double>& eff,
                                           std::vector<std::string> numHists,
                                           std::string denomHist,
                                           int loBin, int hiBin)
{
  //initialize
  denom = 0;
  num = std::vector<double>(numHists.size(), 0);
  eff = std::vector<double>(numHists.size(), 0);

  //sanity check
  if(numHists.empty() || !isDefined(denomHist))
    return false;

  //integrate histograms
  denom = getHist(denomHist)->Integral(loBin, hiBin-1);
  num = std::vector<double>(numHists.size(), 0);

  std::vector<std::string>::iterator numHistsItr = numHists.begin();
  std::vector<double>::iterator numItr = num.begin();
  for(; numHistsItr!=numHists.end(); ++numHistsItr, ++numItr) {
    if(isDefined(*numHistsItr)) (*numItr) = getHist(*numHistsItr)->Integral(loBin, hiBin-1);
  }

  //calculate efficiensies
  if(denom!=0) {
    std::vector<double>::iterator numItr = num.begin();
    std::vector<double>::iterator effItr = eff.begin();
    for(; numItr!=num.end(); ++numItr, ++effItr) {
      (*effItr) = (*numItr)/denom;
    }
  }

  return true;
}
///===================================================
int TrigJpsiRootAnalysis::getPrescale(std::string chain,TriggerBag& trigDecisions) {
  TriggerBag::iterator trigItr = trigDecisions.begin();
  for(; trigItr!=trigDecisions.end(); ++trigItr) {
    if( chain == (*trigItr).name() ) {
      return (*trigItr).prescale();
    }
  }
  return 1;
}
///===================================================
///      . .
///====o==V==o========================================
