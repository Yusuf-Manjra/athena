#ifndef TRIGJETHYPO_TRIGHLTJETHYPOHELPERS_H
#define TRIGJETHYPO_TRIGHLTJETHYPOHELPERS_H


// ********************************************************************
//
// NAME:     TrigHLTJetHypoHelpers.h
// PACKAGE:  Trigger/TrigHypothesis/TrigJetHypo
//
// AUTHOR:
//
// ********************************************************************
//

/* WORK IN PROGRESS _ DO NOT USE ! */

#include <algorithm>
#include <memory>
#include <ostream>
#include <stdexcept>
#include <set>
#include <vector>
#include <fstream>


#include "xAODJet/Jet.h"
#include "TrigJetHypo/TrigHLTJetHypoUtils/TrigHLTJetHypoUtils.h"
#include "./FlowEdge.h"
//////////////////////////////////////

using JetSet = std::set<const xAOD::Jet*>;

struct DescendingEt:
  public std::binary_function<const xAOD::Jet*, const xAOD::Jet*, bool> {
  bool operator()(const xAOD::Jet* l, const xAOD::Jet* r) const;
};

//////////////////////////////////////

class SingleEtaRegionMatcher: public IMatcher{
  /* Match by ordering all jets in the single eta region
     in Et, pair of with the Conditions objects also ordered
     in Et. Event pass if the Et of each jet >= to the threshold
     of the paired Condition.
   */
public:
  ConditionsSorter sorterPred;
  SingleEtaRegionMatcher(const Conditions& cs);
  void match(JetIter b, JetIter e) override;
  bool pass() const override;
  std::pair<JetCIter, JetCIter> passed_iters() const override;
  std::pair<JetCIter, JetCIter> failed_iters() const override;

private:
  Conditions m_conditions;
  bool m_pass;

  JetVector m_passed_jets;
  JetVector m_failed_jets;
};


//////////////////////////////////////

class MaximumBipartiteMatcher: public IMatcher {

  /* Used to find jets pass multithreshold,
     possibly overlapping eta regions
     where any particular jet can be assigned to at most
     one threshold. Uses the Ford Fulkerson Alg.
     See Algorithms, Sedgewick and Wayne 4th edition */

public:
  MaximumBipartiteMatcher(const Conditions& cs);
  void match(JetIter b, JetIter e) override;
  bool pass() const  override;
  std::pair<JetCIter, JetCIter> passed_iters() const override;
  std::pair<JetCIter, JetCIter> failed_iters() const override;

private:
  Conditions m_conditions;
  bool m_pass;
  JetVector m_passed_jets;
  JetVector m_failed_jets;
};


//////////////////////////////////////

struct UncleanableJet: public std::runtime_error{
  UncleanableJet(std::string s):runtime_error(s.c_str()){}    
};

//////////////////////////////////////

class BasicCleaner: public ICleaner{
  /* select jets that satisfy the run 1 cleaning cuts */
 public:
  BasicCleaner(float n90Threshold,
               float presamplerThreshold,
               float negativeEThreshold);
  
  bool operator()(const xAOD::Jet* jet) const override;

 private:
  float m_n90Threshold;
  float m_presamplerThreshold;
  float m_negativeEThreshold;
};

//////////////////////////////////////

class AntiBasicCleaner: public BasicCleaner{
  /* select jets that fail the run 1 cleaning cuts */
public:
  AntiBasicCleaner(float n90Threshold,
                   float presamplerThreshold,
                   float negativeEThreshold);
  
  bool operator()(const xAOD::Jet* jet) const override;
};

//////////////////////////////////////

class NullCleaner: public ICleaner{
  /* apply no cleaning cuts */
public:
  bool operator()(const xAOD::Jet*) const override;
};

//////////////////////////////////////

std::shared_ptr<ICleaner> cleanerFactory(double,
                                         double,
                                         double,
                                         const std::string&);

//////////////////////////////////////

std::shared_ptr<IMatcher> matcherFactory(const Conditions&,
                                         const std::string&);


//////////////////////////////////////

/*
template<typename Cleaner, typename Matcher>
  std::unique_ptr<ICleanerMatcher>
  cleanerMatcherFactory(const Cleaner& cleaner, const Matcher& matcher){
  ICleanerMatcher*  pcm = new CleanerMatcher<Cleaner, Matcher>(cleaner,
                                                               matcher);
  return std::unique_ptr<ICleanerMatcher>(pcm);
}
*/
//////////////////////////////////////

/**
 * FordFulkerson Algorithm - used, for eaxmple,for multiple eta regions,
 * shere each reagion may have > 1 threshold, and the regions do not
 * share jets
 *
 * The FlowEdge and FlowNetwork classes are used by the FF algorithm.
 */


/**
 * FlowNetwork
 * 
 * Adapted from Algorithms, Sedgewick and Wayne, 4th edition.
 * Their java version supplies implemtations of Bag and Queue classeds.
 * These are replaced here by std::multiset and std::queue classes, which 
 * have different interfaces to the java classes.

 * Accessing the FlowElements is done here through std::shared_ptr objects.

 *  The <tt>FlowNetwork</tt> class represents a capacitated network
 *  with vertices named 0 through <em>V</em> - 1, where each directed
 *  edge is of type {@link FlowEdge} and has a real-valued capacity
 *  and flow.
 *  It supports the following two primary operations: add an edge to the network,
 *  iterate over all of the edges incident to or from a vertex. It also provides
 *  methods for returning the number of vertices <em>V</em> and the number
 *  of edges <em>E</em>. Parallel edges and self-loops are permitted.
 *  <p>
 *  This implementation uses an adjacency-lists representation, which 
 *  is a vertex-indexed array of @link{Bag} objects.
 *  All operations take constant time (in the worst case) except
 *  iterating over the edges incident to a given vertex, which takes
 *  time proportional to the number of such edges.
 *  <p>
 *  For additional documentation,
 *  see <a href="http://algs4.cs.princeton.edu/64maxflow">Section 6.4</a> of
 *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 */

using spFE = std::shared_ptr<FlowEdge>;
// using FlowEdgeBag = std::multiset<spFE>;
using FlowEdgeBag = std::vector<spFE>;

class FlowNetwork {
 public:
  
/**
 * Initializes an empty flow network with <tt>V</tt> vertices and 0 edges.
 * param V the number of vertices
 * @throws  if std::length_error <tt>V</tt> < 0
 */

FlowNetwork(int v);
  
  /**  
   * Initializes a flow network from an input stream.
   * The format is the number of vertices <em>V</em>,
   * followed by the number of edges <em>E</em>,
   * followed by <em>E</em> pairs of vertices and edge capacities,
   * with each entry separated by whitespace.
   * @param in the input stream
   * @throws std::out_of_range if the endpoints of any edge are not in 
   *      the prescribed range or if the number of vertices or edges is 
   *      negative.
   */
  
FlowNetwork(std::fstream& in);


/**
 * Returns the number of vertices in the edge-weighted graph.
 * @return the number of vertices in the edge-weighted graph
 */
 
int V() const noexcept;

/**
 * Returns the number of edges in the edge-weighted graph.
 * @return the number of edges in the edge-weighted graph
 */
  
int E() const noexcept;

/**
 * Adds the edge <tt>e</tt> to the network.
 * @param e the edge
 * @throws std::out_of_range unless endpoints of edge are between 0 and V-1
 */
 
void addEdge(spFE e);


/**
 * Returns the edges incident on vertex <tt>v</tt> (includes both edges 
 pointing to and from <tt>v</tt>).
 * @return the edges incident on vertex <tt>v</tt> as a FlowEdgeBag 
 * @param v the vertex
 * @throws std::out_of_range unless 0 <= v < V
 */
FlowEdgeBag adj(int v) const;

// return list of all edges - including self loops

std::vector<spFE> edges() const;

 private:

  void validateVertex(int v) const;
  
  int m_v;  // number of vertices
  int m_e;
  std::vector<FlowEdgeBag> m_adj;
};

std::ostream& operator << (std::ostream& out, const FlowNetwork& n);

/*
 * FordFulkerson
 * Adapted from Algorithms, Sedgewick and Wayne, 4th edition.
 * 
 *
 *  The <tt>FordFulkerson</tt> class represents a data type for computing a
 *  <em>maximum st-flow</em> and <em>minimum st-cut</em> in a flow
 *  network.
 *  <p>
 *  This implementation uses the <em>Ford-Fulkerson</em> algorithm with
 *  the <em>shortest augmenting path</em> heuristic.
 *  The constructor takes time proportional to 
 *  <em>E V</em> (<em>E</em> + <em>V</em>)
 *  in the worst case and extra space (not including the network)
 *  proportional to <em>V</em>, where <em>V</em> is the number of vertices
 *  and <em>E</em> is the number of edges. In practice, the algorithm will
 *  run much faster.
 *  Afterwards, the <tt>inCut()</tt> and <tt>value()</tt> methods take
 *  constant time.
 *  <p>
 *  If the capacities and initial flow values are all integers, then this
 *  implementation guarantees to compute an integer-valued maximum flow.
 *  If the capacities and floating-point numbers, then floating-point
 *  roundoff error can accumulate.
 *  <p>
 *  For additional documentation, see 
 * <a href="http://algs4.cs.princeton.edu/64maxflow">Section 6.4</a>
 *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 */

class FordFulkerson{
 public:

  /**
   * Compute a maximum flow and minimum cut in the network <tt>G</tt>
   * from vertex <tt>s</tt> to vertex <tt>t</tt>.
   * @param G the flow network
   * @param s the source vertex
   * @param t the sink vertex
   * @throws std::out_of_range unless 0 <= s < V
   * @throws std::out_of_range unless 0 <= t < V
   * @throws std::invalid_argument if s = t
   * @throws std::runtime_error if initial flow is infeasible
   */
  
  FordFulkerson(const FlowNetwork& G, int s, int t);

  /**
   * Returns the value of the maximum flow.
   * @return the value of the maximum flow
   */
  double value() const noexcept;

  /**
   * Is vertex <tt>v</tt> on the <tt>s</tt> side of the minimum st-cut?
   * @return <tt>true</tt> if vertex <tt>v</tt> is on the <tt>s</tt> side 
   *    of the mincut, and <tt>false</tt> if vertex <tt>v</tt> is on 
   *    the <tt>t</tt> side.
   * @throws std::out_of_range unless 0 <= v < V
   */
  bool inCut(int v);
  
 private:

  // throw an exception if v is outside prescibed range
  void validate(int v, int V);


  void checkFeasibility(const FlowNetwork& G, int s, int t) const;

  // return excess flow at vertex v
  double excess(const FlowNetwork& G, int v) const noexcept;

  // check optimality conditions
  void check(const FlowNetwork& G, int s, int t);
  bool hasAugmentingPath(const FlowNetwork& G, int s, int t);

  // m_marked[v] = true iff s->v path in residual graph
  std::vector<bool> m_marked;

  // m_edgeTo[v] = last edge on shortest residual s->v path
  std::vector<spFE> m_edgeTo;

  // current value of max flow
  double m_value;
};

#endif
