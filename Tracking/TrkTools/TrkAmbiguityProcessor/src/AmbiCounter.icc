/*
  Copyright (C) 2002-2020 CERN for the benefit of the ATLAS collaboration
*/

#ifndef TrkAmbiguityProcessor_AmbiCounter_icc
#define TrkAmbiguityProcessor_AmbiCounter_icc
#include <array>
#include <vector>
#include <string>
#include "TrkTrack/Track.h"
#include <stdexcept>
#include <algorithm>

template<class EnumType>
class AmbiCounter {
public:
  using Categories = EnumType;
  enum RegionIndex {iBarrel , iTransi , iEndcap , iDBM = 3, nRegions=4, iForwrd = 3};
  enum GlobalCounterIndices {
    nEvents,
    nInvalidTracks,
    nTracksWithoutParam,
    nGlobalCounters,
  };
  //
  AmbiCounter(const std::vector<float> &eta_bounds): m_etaBounds(eta_bounds){
    const std::string errMsg = "eta_bounds size must be " + std::to_string(nRegions);
    if (m_etaBounds.size()!=nRegions) throw std::out_of_range(errMsg);
  }
  
  //convert Category to array index
  size_t 
  idx(const Categories & categoryIndex) const{
    return static_cast<size_t>(categoryIndex);
  }
  
  void 
  resetGlobalCounters(){
    m_globalCounter.fill(0);
  }
  
  //increment event count
  void 
  newEvent(){
    ++m_globalCounter[nEvents];
  }
  
  //return number of events
  int 
  numberOfEvents() const{
    return m_globalCounter[nEvents];
  }
  // increment one bin
  void 
  increment(Categories categoryIdx, unsigned int etaBinIdx) {
    ++m_counter.at(idx(categoryIdx)).at(etaBinIdx);    
  }
  //
  AmbiCounter<EnumType> & operator +=(const AmbiCounter<EnumType> &a) {
  for (unsigned int i=0; i<nGlobalCounters; ++i) {
       m_globalCounter[i]+= a.m_globalCounter[i];
  }
  for (size_t categoryIdx=0; categoryIdx < idx(Categories::kNCounter); ++categoryIdx) {
     for (unsigned int etaBinIdx=0; etaBinIdx < a.m_counter[categoryIdx].size(); ++etaBinIdx) {
        m_counter[categoryIdx][etaBinIdx] += a.m_counter[categoryIdx][etaBinIdx];
     }
  }
  return *this;
}
  //
  void incrementCounterByRegion(Categories categoryIdx,const Trk::Track* track){
   // test
   if (!track) {
      ++m_globalCounter[nInvalidTracks];
      return;
   }
   // use first parameter
   if (!track->trackParameters()) {
      ++m_globalCounter[nTracksWithoutParam];
   } else {
      std::array<int, nRegions> &nTracks = m_counter.at(idx(categoryIdx));
      // @TODO make sure that list of track parameters is not empty
      const double absEta = std::abs(track->trackParameters()->front()->eta());
      ++nTracks.at(etaBin(absEta));
    }
  }
  //
  std::string 
  dumpRegions(const std::string & head,Categories categoryIdx, const int iw =9) const {
    std::stringstream out;
    out << head;
    if (categoryIdx >= Categories::kNCounter) throw std::out_of_range("Array index out of range in AmbiCounter::inc by region");
    const auto & displayedArray = m_counter[idx(categoryIdx)];
    const auto allRegionCounts  = std::accumulate(displayedArray.begin(), displayedArray.end(),0);
    out << std::setiosflags(std::ios::dec) << std::setw(iw) << allRegionCounts;
    for (unsigned int etaBinIdx=0; etaBinIdx < nRegions; ++etaBinIdx) {
       assert( etaBinIdx < m_counter[idx(categoryIdx)].size() );
       out << std::setiosflags(std::ios::dec) << std::setw(iw) << m_counter[idx(categoryIdx)][etaBinIdx];
    }
    out << "\n";
    return out.str();
  }
  //
  int 
  globalCount(GlobalCounterIndices i) const{
    return m_globalCounter[i]; 
  }
  
private:
  std::array<std::array<int, nRegions>,static_cast<size_t>(Categories::kNCounter)> m_counter{};
  std::array<int,nGlobalCounters>                      m_globalCounter{};
  const std::vector<float>  &m_etaBounds;           //!< eta intervals for internal monitoring
  size_t 
  etaBin(const double val){
    size_t regionIdx{}; 
    //eta *must be* in ascending order in the m_etaBounds vector
    for (;regionIdx< nRegions; ++regionIdx){
      if (val < m_etaBounds[regionIdx]) break;
    }
    return regionIdx;
  }
};

#endif
