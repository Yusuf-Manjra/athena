package AtlasReflex

author RD Schaffer <R.D.Schaffer@cern.ch>
author Kyle Cranmer <cranmer@cern.ch>
author Marcin Nowak <Marcin.Nowak@cern.ch>

use ExternalPolicy ExternalPolicy-* External
use AtlasRELAX     AtlasRELAX-*     External -no_auto_imports
use AtlasROOT      AtlasROOT-*      External
use_unless tag=ROOT_GE_6_00  pkg=Reflex ver="v*" root="LCG_Interfaces"


#-----------------------------------------------------------------------------
#
# Definitions for the Reflex dictionary generator 
#
macro merge_dict_rootmap_cmd ${GaudiPolicy_root}/scripts/merge_files.py
make_fragment reflex_dict -header=reflex_dict_header -trailer=reflex_dict_trailer -dependencies
make_fragment merge_dict_rootmap  -header=merge_dict_rootmap_header  -dependencies
make_fragment install_lcgdict_pcms -header=install_lcgdict_pcms_header
make_fragment DataLink_selection.xml
make_fragment ElementLink_selection.xml
make_fragment ElementLinkVector_selection.xml
make_fragment Navigable_selection.xml
make_fragment NavigableDict.h
make_fragment ElementLinkDict.h
make_fragment DataLinkDict.h

#-----------------------------------------------------------------------------
#
# Pattern for applying the generator
#
# apply_pattern lcgdict dict=... headerfiles="..." selectionfile="..."  \
#                                [ extralibfiles="..." ] \
#                                [ navigables="..." ] \
#                                [ dataLinks="..." ] \
#                                [ elementLinks="..." ] \
#                                [ elementLinkVectors="..." ] \
#                                [ options="..." ]
#   where:
#
#     dict              is the name of the dictionary
#     headerfiles       gives the list of header files to be parsed
#			Note: this can be given as "-s=<dir name> <file1> <file2> ..."
#     selectionfile	Name of selection file (typically just selection.xml)
#			This file must be put in the include dir, i.e. ../<package>
#     extraselection    List of additional files to be included into
#                       the selection.xml file.
#     extralibfiles	gives the optional additional C++ files to be
#			compiled in the generated library 
#     navigables        Provdes a list of class names for which the Navigable
#                       dictionaries are created.  This is needed if a client class
#                       wants to inherit from Navigable<T>, and T is a class defined 
#                       in the current package.  
#                       Requires the class to be a DataVector and the contained elements must 
#                       implement the INavigable interface.
#                       This adds the required information to the selection file.
#                       Note that this also does the ElementLink, ElementLinkVector, and DataLink part.
#     dataLinks         Provdes a list of class names for which clients can create a DataLink.
#                       One should use the navigables pattern if the class fulfills the navibables requirements.  
#                       Normally, a class is listed in the dataLinks section if it is not a DataVector.
#                       This adds the required information to the selection file.
#     elementLinks      Provdes a list of class names for which a client can create an ElementLink or an ElementLinkVector.
#                       Requires the class to be a DataVector, but does not require the contained 
#                       elements to implement the INavigable interface.  
#                       One should use the navigables pattern if the class fulfills the navigables requirements.
#                       This adds the required information to the selection file.
#     elementLinkVectors Deprecated, use elementLinks instead.
#                       Provdes a list of class names for which clients can create an ElementLinkVector
#                       This adds the required information to the selection file.
#                       Note that this also does the DataLink part. But one must 
#                       also add the class names to "elementLinks=..."
#     options           options for the lcgdict command. Possible options are:
#                       --pool : Generate minimal dictionary required
#                                for POOL persistency, no methods
#
#   Note on Conventions: The use of the navigables or dataLinks pattern should be thought of
#                        as providing a service to clients downstream.  By declaring your class
#                        in the list of navigables or dataLinks, you are allowing clients to 
#                        navigate to or create dataLinks to your class.  
#
#
#  > With this pattern, 
#
#     + a directory ../$(bin)dict/<dict> 
#     + a library lib<dict>Dict.so 
#
#     will be created for each dictionary
#
#  > Two constituents <dict>Gen and <dict>Dict are generated by this pattern
#
#-----------------------------------------------------------------------------
set GCCXML_USER_FLAGS "" target-darwin&target-x86_64 " -m64"

# MN: this gets rid of the 'register' specification warnings from CLHEP in gcc48
# MN: make genreflex warnings fatal for gccxml but not for ROOT6
macro genreflex_options " --fail_on_warnings "   \
   ROOT_GE_6_00 " -Wno-deprecated "
# MN: and this prevents deprecated hash_map warning (from Gaudi) in gcc48
macro_append genreflex_options " -D_GLIBCXX_PERMIT_BACKWARD_HASH "

pattern lcgdict \
  private ; \
  macro gcc_user_flags "" target-darwin&target-x86_64 " -m64" ; \
  macro dict_dir "$(bin)dict" ; \
  macro_append <dict>Gen_dependencies " install_includes" ; \
  macro genreflex_cmd "python $(AtlasReflex_root)/cmt/athena_genreflex_wrapper.py <dict> \
                     python $(AtlasReflex_root)/genreflex/lib/python/genreflex/genreflex.py" \
        ROOT_GE_6_00 "genreflex"  #for ROOT v6+ use the default genreflex  ; \
  document reflex_dict <dict>Gen <headerfiles> dictionary=<dict> ; \
  library <dict>Dict -suffix=_<dict> <extralibfiles> -s=$(dict_dir)/<dict> *.cpp ; \
# Force optimized compilation of the dictionary for minimum disk space
  macro cppdebugflags      "$(cppdebugflags)" \
        target_<dict>Dict  " -O2 -DNDEBUG " ; \
  macro_append <dict>Dict_pp_cppflags  " -I. -ftemplate-depth-125 " ; \
  macro_append <dict>Dict_pp_cppflags  " -Wno-overloaded-virtual " ; \
  macro_append <dict>Dict_pp_cppflags  ""  separate-debug&target-opt&target-linux  " -g " ; \
  macro_append <dict>Dict_dependencies " <dict>Gen " ; \
  macro_append <dict>Dict_dependencies " $(<package>_library_dependencies)" ; \
#  macro_prepend <dict>Dictlinkopts " $(<package>_linkopts)" ; \
# macro reflex_dict<dict>_reset_stamp " $(<dict>Dictstamps) " ; \
  macro reflex_dict<dict>_clean_target " <dict>Dictclean " ; \
  macro reflex_dict<dict>_selection_file " ../<package>/<selectionfile> " ; \ 
  macro reflex_dict<dict>_extra_selection " <extraselection> " ; \
  macro reflex_dict<dict>_package " <package> " ; \
  macro reflex_dict<dict>_navigables " <navigables> " ; \ 
  macro reflex_dict<dict>_data_links " <dataLinks> " ; \ 
  macro reflex_dict<dict>_element_links " <elementLinks> " ; \ 
  macro reflex_dict<dict>_element_link_vectors " <elementLinkVectors> " ; \ 
  macro reflex_dict<dict>_opt_rootmap " --rootmap=<dict>Dict.dsomap --rootmap-lib=$(libprefix)<dict>Dict.$(shlibsuffix) " ; \
  macro reflex_dict<dict>_opt_pcm ""  \
         ROOT_GE_6_00 " --multiDict -l$(dict_dir)/<dict>/<dict>Dict.$(shlibsuffix) " ; \
  macro reflex_dict<dict>_options " <options>  --select=$(dict_dir)/<dict>_selection.xml  -DNDEBUG $(reflex_dict<dict>_opt_rootmap) $(reflex_dict<dict>_opt_pcm) " ; \
# reflex_dict_options_cppflags comes in from AtlasPolicy
  macro_append reflex_dict<dict>_options " $(reflex_dict_options_cppflags) " ; \
  macro_append reflex_dict<dict>_options "" \
               x86_64&&32          " --gccxmlopt=--gccxml-cxxflags --gccxmlopt=-m32" ; \
#  macro_append reflex_dict<dict>_options " --no_membertypedefs " ; \
  macro <dict>Dict_shlibflags "$(componentshr_linkopts) $(use_linkopts) $(Reflex_linkopts) $(<package>_extra_shlibflags)" ; \
  apply_pattern generic_declare_for_link files='$(dict_dir)/<dict>/<dict>Dict.dsomap' prefix=$(tag)/lib name=<dict>Dict_ kind=<dict>dictrootmap ; \
  macro_append install_<dict>Dict_<dict>dictrootmap_dependencies " <dict>Gen " ; \
  apply_pattern optdebug_library name='<dict>Dict' ; \
  macro_append check_install_<dict>Dict_<dict>dictrootmap_dependencies " <dict>Gen " ; \
  apply_pattern merge_dict_dsomap dict=<dict> headerfiles=<headerfiles> ; \
  apply_pattern install_pcm       dict=<dict> headerfiles=<headerfiles> ; \
  end_private 


# Conditional patterns used by lcgdict:

pattern install_pcm \
   macro install_pcm_<dict> "empty_install_pcm" \
        ROOT_GE_6_00 "do_install_pcm" ; \
   apply_pattern ${install_pcm_<dict>} dict=<dict> headerfiles=<headerfiles>

pattern empty_install_pcm  macro dummy "<dict> <headerfiles>"

pattern do_install_pcm \
   macro InstallPCM_<dict>_dependencies <dict>Gen ; \
   document install_lcgdict_pcms InstallPCM_<dict> dict=<dict> <headerfiles> 


pattern merge_dict_dsomap \
  private ; \
   macro run_merge_dict_cmd "do_real_merge_dict_dsomap" \
         rootmap_merge      "do_real_merge_dict_dsomap" \
         no_rootmap         "do_null_merge_dict_dsomap" ; \
   apply_pattern $(run_merge_dict_cmd) dict=<dict> headerfiles=<headerfiles> ; \
  end_private

pattern do_real_merge_dict_dsomap \
  document merge_dict_rootmap <dict>DictMerge <headerfiles> dictionary=<dict> ; \
  macro_append <dict>DictMerge_dependencies " <dict>Dict "

pattern do_null_merge_dict_dsomap \
  private ; \
   macro dummy_for_<dict>DictMerge "<dict>" ; \
   macro dummy_for_<headerfiles>DictHeaders "<headerfiles>" ; \
  end_private

# helper pattern to execute patterns only for ROOT5
pattern root5only_pattern \
   macro root5only_pattern_name "<pattern_name>" \
         ROOT_GE_6_00 "empty_pattern" ; \
   apply_pattern ${root5only_pattern_name} 

pattern empty_pattern 


private
# Building gccxml_plugin.
use AtlasPolicy    AtlasPolicy-*
use gmp v* LCG_Interfaces
# gmp isn't available in experimental LCG
macro gmp_home $(LCG_EXTERNAL)/gmp/5.1.1/$(LCG_system)
#macro gmp_native_version 5.1.1
build_strategy no_prototypes

#HACK, should be fixed in GaudiPolicy. Get rid of icc command line options
macro_remove cppflags "" target-icc "-wd383 -wd981 -wd1418 -wd1419 -we1011 -we117 -wd82 -wd522 -wd444 -wd304 -Wno-deprecated"

macro_prepend cppflags " -Wno-literal-suffix -I$(gcc_home)/lib/gcc/x86_64-unknown-linux-gnu/$(gcc_native_version)/plugin/include -I$(gcc_home)/lib/gcc/x86_64-unknown-linux-gnu/$(gcc_native_version) -I$(gmp_home)/include -DGCCXML_PLUGIN_VERSION=\$(q)1.0sss2\$(q) -DGCCXML_PLUGIN_VERSION_FULL=\$(q)1.0.2sss2\$(q) "
macro_prepend cflags " -I$(gcc_home)/lib/gcc/x86_64-unknown-linux-gnu/$(gcc_native_version)/plugin/include  -I$(gcc_home)/lib/gcc/x86_64-unknown-linux-gnu/$(gcc_native_version)  -DGCCXML_PLUGIN_VERSION_FULL=\$(q)1.0.2sss2\$(q) -I$(gmp_home)/include "

# Remove -m32 from compilation lines.  Need to build to match the compiler used.
macro_remove cflags " -m32 "
macro_remove cppflags " -m32 "
macro_remove cpplinkflags " -m32 "
macro_remove_regexp cppflags " -march=[^ ]+ "
macro_remove shlibflags "-m32"
macro_remove shlibbuilder "-m32


# Use gcc to compile the plugin, but don't override the names if we're
# already configured for gcc.
macro cc_name "gcc" gcc "$(cc_name)"
macro cpp_name "g++" gcc "$(cpp_name)"



pattern gccxml_plugin_lib \
        library gccxml_plugin -s=../gccxml_plugin gccxml_plugin.cxx xml.cxx

# Compile the gxxcml plugin only for ROOT5
apply_pattern root5only_pattern pattern_name="gccxml_plugin_lib" 

apply_pattern declare_scripts files="../gccxml_plugin/gccxml_plugin"
