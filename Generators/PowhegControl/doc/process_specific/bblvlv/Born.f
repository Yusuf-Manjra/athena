      subroutine setborn(p,bflav,born,bornjk,bmunu)
c Wrapper subroutine to call OL Borns
      implicit none
      include 'nlegborn.h'
      integer, parameter :: nlegs=nlegbornexternal
      real * 8 p(0:3,nlegs),bornjk(nlegs,nlegs)
      integer bflav(nlegs), m, n
      real * 8 bmunu(0:3,0:3,nlegs),born
      real * 8 OLborn
      real * 8 OLbornjk(nlegs,nlegs), OLbmunu(0:3,0:3,nlegs)
      logical openloopsreal,openloopsvirtual
      common/copenloopsreal/openloopsreal,openloopsvirtual
      call openloops_born(p,bflav,OLborn,OLbornjk,OLbmunu)
      born=OLborn
      bornjk=OLbornjk
      bmunu=OLbmunu
      end subroutine setborn

      subroutine borncolour_lh
c Wrapper subroutine to call the OL code to associate
c a (leading) color structure to an event.
      implicit none
      include 'nlegborn.h'
      include 'LesHouches.h'
      include 'pwhg_rad.h'
      include 'pwhg_flst.h'
      include 'pwhg_kn.h'
      real * 8 p(0:3,nlegborn)
      integer bflav(nlegborn),is_fs_flav(nlegborn),
     1     is_fs(nlegborn),isfslength,color(2,nlegborn)
      integer i,j,iret,icount,iprint,ifl
      integer OLcolor(2,nlegborn), OLifl
      logical openloopsreal,openloopsvirtual
      common/copenloopsreal/openloopsreal,openloopsvirtual

c This does not have problems due to smartsig. Before calling this function, POWHEG
c calls the setborn matrix element explicitly, bypassing smartsig, in such a way
c that colour subamplitudes are correctly stored.

      do i=1,flst_bornlength(rad_ubornsubp)
         bflav(i)=idup(i)
         if (bflav(i).eq.21) bflav(i)=0
      enddo
      call getisfsparticles(nup,bflav,flst_bornres(:,rad_ubornsubp),
     1     isfslength,is_fs)
      do j=1,isfslength
        is_fs_flav(j) = bflav(is_fs(j))
        p(:,j) = kn_cmpborn(:,is_fs(j))
      enddo

      icount = 0
      iprint = 2

      call allow_all_colors

 1    continue
      icount = icount + 1
      if(icount.gt.1000000) then
         write(*,*) ' borncolour_lh : cannot find colour configuration '
         write(*,*) ' consistent with resonance assignment. Exiting ... '
         call exit(-1)
      elseif(icount.gt.iprint) then
         write(*,*) ' borncolour_lh : try another one '
         write(*,*) ' borncolour_lh:',iprint,' tries; keep trying'
         iprint = iprint*10
      endif

      call openloops_borncolour_ifl(p,is_fs_flav,OLcolor,OLifl)
      color=OLcolor
      ifl=OLifl

      do j=1,isfslength
         icolup(:,is_fs(j))=color(:,j)
      enddo

      call complete_resonance_colours(iret)
      if(iret.lt.0) then
         call disallow_color(ifl)
         goto 1
      endif

      end

      subroutine finalize_lh
c Originally, only e- nu_e mu+ nu_mu~ (-11, 12, 13, -14) events are generated.
c It is an absolute must, however, to have the option to generate also other
c combinations of leptons in the final state like e+ nu_e~ mu- nu_mu~ 
c (11, -12, -13, 14) or e+ nu_e~ tau- nu_tau~ (-11, 12, 15, -16), etc. 
c The matrix elements for any different family combination in the final 
c state (meaning that one top decays in one family, the other in another family
c of leptons) are identical, if all the lepton masses are neglected.
c It is thus possible to obtain such events simply by modifying the event after 
c it has been generated by simply relabelling the particles.
c 
c In the following, we implement such a relabelling. The final state labels are 
c chosen randomly and are proportional to the corresponding branching ratios.
c With three families {e, mu, tau}, there are 6 possible different family 
c combinations (see below). We partition unit probability into 6 parts, such 
c that P[e- nu_e  mu+ nu_mu~] == P[e+ nu_e~ mu- nu_mu] and such that 
c P[tau- nu_tau mu+ nu_mu~] = Br(W > tau+nu_tau)/Br(W > e nu_e) P[e- nu_e  mu+ nu_mu~],
c similarly for the other combinations. We throw a random number and pick the 
c corresponding partition and the combination associated to it. 
c The weight of the event is also modified (see below).
c
c We implement the following options:
c            channel: 0 ... only e- nu_e  mu+ nu_mu~     (-11,  12,  13, -14)
c                     1 ... only e+ nu_e~ mu- nu_mu      ( 11, -12, -13,  14)
c                     2 ... both 0 and 1 options         (-11,  12,  13, -14) or ( 11, -12, -13,  14) (kept for backward compatibility)
c                     3 ... only e- nu_e  tau+ nu_tau~   (-11,  12,  15, -16)
c                     4 ... only e+ nu_e~ tau- nu_tau    ( 11, -12, -15,  16)
c                     5 ... only tau- nu_tau  mu+ nu_mu~ (-15,  16,  13, -14)
c                     6 ... only tau+ nu_tau~ mu- nu_mu  ( 15, -16, -13,  14)
c                     7 ... options 0,1,3,4,5 or 6
c
c If running with channel 0 or 1, the weight of the event is left unmodified. In the channel==2
c mode the weight of the event is doubled. For channels 3-6, the weight is modified 
c by the corresponding branching ratios ratio (3,4 .. br_tau/br_mu; 5-6 .. br_tau/br_e). 
c In channel 7, the resulting weight will be:
c   W = 2*w + 2*w*br_tau/br_mu + 2*w*br_tau/br_e,
c where w is the original weight.
c
c The branching ratio ratios can be input using: 
c            br_tau/br_e ... (default 0.99926856, same as in Pythia 8.210) the ratio of W > tau+nu_tau and W > e+nu_e branching ratios
c            br_tau/br_mu ... (default 0.999270413, same as in Pythia 8.210) the ratio of W > tau+nu_tau and W > mu+nu_mu branching ratios
c
c The tau mass can be input using:
c            mtau ... (default 1.77682, same as in Pythia 8.210), tau mass
c The tau mass in the matrix element is neglected, the mass above is used 
c to reshuffle the generated tau momentum, such that it appears massive.
c Keep in mind that an estimate of the impact of neglecting the tau mass 
c has not been attempted in any way. Also note that the tau lepton is generated 
c stable and we rely on the Shower Monte Carlo program the LHE events are passed 
c to to perform its decay. 
c The reshuffling is performed using the routines in reshufflemoms.f, see the call
c to lhefinitemasses in finalize_lh. mtau is set in init_couplings.f, into physpar_ml(3), 
c all the other physpar_ml(q) are set to 0 by default.
c
c Note: this simple relabeling scheme cannot be applied to same family decays, in
c which case there are further feynman diagrams, currently not included in the matrix
c element. The same family decays have been requested, and are in the process
c of being implemented.
      implicit none
      logical, save :: ini = .true.
      integer, save :: channel
      real * 8, save :: brtau2brmu, brtau2bre, brmu2bre, mtau
      real * 8 powheginput
      real * 8 randomNumber, random
      real * 8, save :: weights(9), weightSum
      integer i
      external random
      if (ini) then
        channel = powheginput("#channel")
        if (channel < 0) channel = 0
        brtau2brmu = powheginput('#br_tau/br_mu')
        if (brtau2brmu < 0) brtau2brmu = 0.999270413
        brtau2bre = powheginput('#br_tau/br_e')
        if (brtau2bre < 0) brtau2bre = 0.99926856
        brmu2bre = brtau2bre / brtau2brmu
c       prepare probability partitions
        weightSum = 2d0 + 2d0*brtau2brmu + 2d0*brtau2bre
        weightSum = weightSum + 1d0/brmu2bre + brmu2bre
        weightSum = weightSum + brtau2brmu*brtau2bre
        weights(1:2) = 1d0
        weights(3:4) = brtau2brmu
        weights(5:6) = brtau2bre
        weights(7) = 1d0/brmu2bre
        weights(8) = brmu2bre
        weights(9) = brtau2brmu*brtau2bre
        do i=2,9
           weights(i) = ( weights(i) + weights(i-1) )
        enddo
        do i=1,9
           weights(i) = weights(i) / weightSum
        enddo
        ini = .false.
      endif 

c   throws a random number even when its not needed (settings with individual
c   channels) to ensure that the random number sequence is identical for all the
c   channels (i.e. the output will be binary identical up to the sign of 
c   and the PDF code of the leptons)
      randomNumber = random()
c   choose according to the channel
      if (channel == 0) then
c       do nothing        
      elseif (channel == 1) then
c       flip the signs of 11, 12, 13 and 14 particles
        call flip_flavours
      elseif (channel == 2) then
        if (randomNumber > 0.5) then
          call flip_flavours
        endif
c       we should also double the xsection, this is done by modifying
c       the rad_branching in init_processes.f

c                     3 ... only e- nu_e  tau+ nu_tau~   (-11,  12,  15, -16)
c                     4 ... only e+ nu_e~ tau- nu_tau    ( 11, -12, -15,  16)
c                     5 ... only tau- nu_tau  mu+ nu_mu~ (-15,  16,  13, -14)
c                     6 ... only tau+ nu_tau~ mu- nu_mu  ( 15, -16, -13,  14)
c                     7 ... options 0,1,3,4,5 or 6
      elseif (channel == 3) then
        call mu2tau
c       the weight also needs modifying, see above
      else if (channel == 4) then
        call mu2tau
        call flip_flavours
c       the weight also needs modifying, see above
      elseif (channel == 5) then
        call e2tau
c       the weight also needs modifying, see above
      else if (channel == 6) then
        call e2tau
        call flip_flavours
c       the weight also needs modifying, see above
      else if (channel == 7) then
        do i=1,9
          if ( randomNumber < weights(i) ) exit
        enddo
        select case (i) 
          case (1) 
c           do nothing
          case (2)
            call flip_flavours
          case (3)
            call mu2tau
          case (4)
            call mu2tau
            call flip_flavours
          case (5)
            call e2tau
          case (6)
            call e2tau
            call flip_flavours
          case (7)
            call mu2e
          case (8)
            call e2mu
          case (9)
            call e2tau
            call mu2tau
        end select
      else 
        print*, "finalize_lh: value for channel=",channel,"is not allowed. Exiting!"
        call exit(-1)
      endif
c reshuffle momenta to set the masses of final state particles neglected in the ME
      call lhefinitemasses
      call check_leshouches
      contains 
      subroutine flip_signs
      implicit none
      include 'LesHouches.h'
      integer iup
      do iup = 1, nup
        if (abs(idup(iup)) > 10 .and. abs(idup(iup)) < 17) then
          if (idup(iup) < 0) then 
            idup(iup) = abs(idup(iup))  
          else if (idup(iup) > 0) then 
            idup(iup) = - abs(idup(iup))  
          endif
        endif
      enddo
      end subroutine
      subroutine flip_flavours
      implicit none
      include 'LesHouches.h'
      integer iup, wsign, lindex, wdaug(-1:1,0:1), tmppdg(0:1)
      integer i1,i2,i3,i4,r1,r2
c     reconstruct W+ and W- daughters
      do iup = 1, nup
        if (mothup(1,iup) > 0) then
          if (abs(idup(mothup(1,iup))) == 24) then
            wsign = sign(1, idup(mothup(1,iup))) ! +1 or -1 for W+ or W-
            lindex = mod( abs(idup(iup)), 2) ! 1 for leptons, 0 for neutrinos
            wdaug(wsign, lindex) = iup
          endif
        endif
      enddo 
c     store W- lepton flavours in a temp array
      tmppdg(0) = idup(wdaug(-1, 0))
      tmppdg(1) = idup(wdaug(-1, 1))
c     flip W- lepton flavours, W- leptons should keep their signs but take the flavours of W+ leptons
c      i1 = idup(wdaug(+1, 0))
c      i2 = idup(wdaug(-1, 0))
c      i3 = idup(wdaug(+1, 1))
c      i4 = idup(wdaug(-1, 1))
c      r1 = sign(i1, i2)
c      r2 = sign(i3, i4)
      idup(wdaug(-1, 0)) = sign(idup(wdaug(+1, 0)), idup(wdaug(-1, 0)))
      idup(wdaug(-1, 1)) = sign(idup(wdaug(+1, 1)), idup(wdaug(-1, 1)))
c     flip W+ lepton flavours
      idup(wdaug(+1, 0)) = sign(tmppdg(0), idup(wdaug(+1, 0)))
      idup(wdaug(+1, 1)) = sign(tmppdg(1), idup(wdaug(+1, 1)))
      end subroutine
      subroutine e2tau
      implicit none
      include 'LesHouches.h'
      integer iup, sgn
      do iup = 1, nup
        if (abs(idup(iup)) == 11) then
          idup(iup) = sign(15,idup(iup))
        else if (abs(idup(iup)) == 12) then
          idup(iup) = sign(16,idup(iup))
        endif
      enddo
      end subroutine
      subroutine mu2tau
      implicit none
      include 'LesHouches.h'
      integer iup, sgn
      do iup = 1, nup
        if (abs(idup(iup)) == 13) then
          idup(iup) = sign(15,idup(iup))
        else if (abs(idup(iup)) == 14) then
          idup(iup) = sign(16,idup(iup))
        endif
      enddo
      end subroutine
      subroutine mu2e
      implicit none
      include 'LesHouches.h'
      integer iup, sgn
      do iup = 1, nup
        if (abs(idup(iup)) == 13) then
          idup(iup) = sign(11,idup(iup))
        else if (abs(idup(iup)) == 14) then
          idup(iup) = sign(12,idup(iup))
        endif
      enddo
      end subroutine
      subroutine e2mu
      implicit none
      include 'LesHouches.h'
      integer iup, sgn
      do iup = 1, nup
        if (abs(idup(iup)) == 11) then
          idup(iup) = sign(13,idup(iup))
        else if (abs(idup(iup)) == 12) then
          idup(iup) = sign(14,idup(iup))
        endif
      enddo
      end subroutine
      end


      subroutine complete_resonance_colours(iret)
      implicit none
      integer iret
      include 'LesHouches.h'
      integer iup,kup,moth,col(nup),acol(nup),ncol,nacol,jcol,jacol
      logical is_coloured
      external is_coloured
c Look for coloured resonances      
      do iup = 3,nup
         if(istup(iup).gt.1) then
            ncol = 0
            nacol = 0
            do kup = 3,nup
               if(istup(kup).eq.1) then
                  moth = mothup(1,kup)
                  do while (moth.ne.0)
                     if(moth.eq.iup) exit
                     moth = mothup(1,moth)
                  enddo
                  if(moth.ne.0) then
                     if(icolup(1,kup).ne.0) then
                        ncol = ncol + 1
                        col(ncol) = icolup(1,kup)
                     endif
                     if(icolup(2,kup).ne.0) then
                        nacol = nacol + 1
                        acol(nacol) = icolup(2,kup)
                     endif
                  endif
               endif
            enddo
            do jacol = 1,nacol
               do jcol = 1,ncol
                  if(col(jcol).eq.acol(jacol)) then
                     col(jcol) = 0
                     acol(jacol) = 0
                  endif
               enddo
            enddo
c at most one colour and one anticolour should be left
            icolup(:,iup) = 0
            do jcol = 1,ncol
               if(col(jcol).ne.0) then
                  icolup(1,iup) = col(jcol)
                  col(jcol) = 0
                  if(.not.all(col(1:ncol).eq.0)) then
                     iret = -1
                     return
                  else
                     exit
                  endif
               endif
            enddo
            do jacol = 1,nacol
               if(acol(jacol).ne.0) then
                  icolup(2,iup) = acol(jacol)
                  acol(jacol) = 0
                  if(.not.all(acol(1:nacol).eq.0)) then
                     iret = -1
                     return
                  else
                     exit
                  endif
               endif
            enddo
c TODO : check that the colour assignment is consistent with flavour
            if(( idup(iup).eq. 6 .and. .not. (icolup(1,iup).ne.0.and.icolup(2,iup).eq.0) ) .or.
     1         ( idup(iup).eq.-6 .and. .not. (icolup(2,iup).ne.0.and.icolup(1,iup).eq.0) ) .or.
     2         ( abs(idup(iup)) .ne. 6 .and. .not. (icolup(1,iup).eq.0.and.icolup(2,iup).eq.0) ) ) then
               iret = -1
               return
            endif
         endif
      enddo
      iret = 0
      end

      
      integer function allowed_color(ifl)
      implicit none
      integer ifl,iallowed
      call pilot_allow_color(ifl,'g',iallowed)
      allowed_color = iallowed
      end

      subroutine disallow_color(ifl)
      implicit none
      integer ifl,iallowed
      call pilot_allow_color(ifl,'s',iallowed)
      end

      subroutine allow_all_colors
      implicit none
      integer ifl,iallowed
      call pilot_allow_color(ifl,'r',iallowed)
      end
      
      subroutine pilot_allow_color(ifl,mode,iallowed)
      implicit none
c mode = g,s,r for get, set, reset
      integer ifl,iallowed
      character * 1 mode
c
      integer, save :: maxforbid=0
      integer, allocatable, save :: forbidden(:)
      integer, allocatable :: saveforbidden(:)
      integer, save :: nforbid=0
      integer k
      if(mode == 'r') then
         nforbid = 0
      elseif(mode == 'g') then
         do k=1,nforbid
            if(forbidden(k) == ifl) then
               iallowed = 0
               return
            endif
         enddo
         iallowed = 1
      elseif(mode == 's') then
         if(nforbid >= maxforbid) then
            if(allocated(forbidden)) then
               allocate(saveforbidden(maxforbid))
               saveforbidden = forbidden
               deallocate(forbidden)
               allocate(forbidden(maxforbid+10))
               forbidden(1:maxforbid) = saveforbidden
               deallocate(saveforbidden)
               maxforbid = maxforbid+10
            else
               maxforbid = maxforbid+10
               allocate(forbidden(maxforbid))
            endif
         endif
         nforbid = nforbid + 1
         forbidden(nforbid) = ifl
      else
         write(*,*) ' pilot_allow_color: mode ',mode,' not allowed!'
         write(*,*) ' exiting ...'
         call exit(-1)
      endif
      end
